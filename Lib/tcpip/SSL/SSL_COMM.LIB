/* START LIBRARY DESCRIPTION *********************************************
SSL_COMM.LIB
	SSL Module, v. 1.04
	Copyright (c) 2003, ZWorld.

DESCRIPTION: SSL Communications functions and API
             This library is intended to only be included by SSL.LIB
             for communications functionality.

END DESCRIPTION **********************************************************/

/*** BeginHeader */

#ifndef __SSL_COMM_LIB__
#define __SSL_COMM_LIB__

/*** EndHeader */

////////////////////////////////////////////////////////////////////////////////
// SSL Communication Functions (write)
// Note that SSL *requires* a reliable transport layer, such as TCP,
// or it will not work (UDP is not an option with SSL)
////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader ssl_write */
int ssl_write(ssl_Socket*, char*, int);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_write                              <SSL_COMM.LIB>

SYNTAX: int ssl_write(ssl_Socket* state, char *data, int length);

DESCRIPTION: Using an active SSL connection, send an arbitrary amount of
             data, first encapsulating the data in the SSL record format,
             and then encrypting the record using the current ciphersuite.
             !!! This function blocks, it is comparable to sock_write

PARAMETER 1: Active SSL connection state structure
PARAMETER 2: Pointer to data
PARAMETER 3: Length of data

RETURN VALUE: Number of bytes sent, -1 on error, 0 on connection closed

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_write(ssl_Socket* state, char *data, int length) {
	auto int offs, ret_val;

	// If no data, do nothing
	if(length <= 0) {
    	return 0;
   }

   _ssl_assert(state != NULL);
   _ssl_assert(data != NULL);

   offs = 0;
   while(offs < length) {
   	ret_val = ssl_fastwrite(state, &data[offs], length - offs);
      if(ret_val >= 0) {
       	offs += ret_val;
         if(offs >= length)
         {
          	return length;
         }
      }
      else {
       	return -1;
      }
      if(!ssl_tick(state) || ssl_is_done(state) || ssl_error(state)) {
      	return 0;
      }
   }
   return length;
}

/*** BeginHeader ssl_fastwrite */
int ssl_fastwrite(ssl_Socket*, char*, int);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_fastwrite                          <SSL_COMM.LIB>

SYNTAX: int ssl_fastwrite(ssl_Socket* state, char* data, int length);

DESCRIPTION: Using an active SSL connection, send an arbitrary amount of
             data, first encapsulating the data in the TLS record format,
             and then encrypting the record using the current ciphersuite
             This function is non-blocking, this is comparable to
             sock_fastwrite.

PARAMETER 1: Active SSL connection state structure
PARAMETER 2: Pointer to data buffer
PARAMETER 3: Length of data

RETURN VALUE: Number of bytes sent, -1 on error

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_fastwrite(ssl_Socket* state, char* data, int data_len) {
   _ssl_assert(state != NULL);

   if(!_ssl_is_valid_io_state(state)) {
		return 0;
	}

   if(data_len <= 0) {
    	return 0;
   }
   return ssl_xfastwrite(state, paddr(data), data_len);
}

/*** BeginHeader ssl_xfastwrite */
int ssl_xfastwrite(ssl_Socket*, long, long);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_xfastwrite                         <SSL_COMM.LIB>

SYNTAX: int ssl_xfastwrite(ssl_Socket* state, long data, int length);

DESCRIPTION: Send data using an active SSL connection. This function
             is non-blocking, and simply copies the data to be written
             into the write buffer. All record creation is handled
             by ssl_create_record, and all communications are driven
             by calling ssl_tick.

PARAMETER 1: SSL state structure
PARAMETER 2: Pointer to xmem data
PARAMETER 3: Length of data

RETURN VALUE: Number of bytes written

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_xfastwrite(ssl_Socket* state, long data, long data_len) {

// The write buffer is setup as follows:
// v-- write_buf             				   			                v-- end_data
// +----+--------------------------------+-------------------------+-----------+
// |    | Header | Encrypted Data | MAC* | H_RES |Unencrypted Data | F_RES |   |
// +----+--------------------------------+-------------------------+-----------+
//      ^-- start_enc                    ^-- start_data         end_write_buf--^
//
// *The MAC space may include padding for block ciphers after the MAC
//
// Notes:
// - The MAC and header are part of the encrypted data, so no pointer to
//   them is needed
// - Records are created in-place, and the header is added at the beginning
//   of the encrypted data in a reserved space once the data has been MAC'ed
//   and encrypted. This is due to the fact that we cannot build the header
//   until that point, but we need it at the beginning to simplify the write
//   code.
// - The buffer is circular, so any of the data sections may be split over
//   the end (end_write_buf)
// - end_data should never pass start_enc.
// - The reason for reserving space for the record header is so that we can
//   have multiple processed records present in the buffer, and so that once
//   record data is processed, we can ignore the structure of it, and just
//   write bytes to the socket consecutively from start_enc to start_data.
// - The reserve scheme works since the header size is a constant. The footer
//   may be variable (to accomodate block cipher padding) but this can be
//   adjusted at run time by changing wr_state->footer_reserve
// - We also need to reserve space after end_data, for the MAC and any padding
//   necessary.
// - The header reserve space is reserved each time a record is created. (in
//   create_record) The footer reserve space is checked when new data is
//   written. (in fastwrite)
//
// States:
// start_enc == start_data 					  -> no encrypted data
// start_data == end_data - header_reserve  -> no unencrypted data
// end_data < start_data   					  -> unencrypted data wraps
// start_data < start_enc  					  -> encrypted data wraps
// end_data > start_enc && end_data < start_data -> ERROR, overlapped data

// data, data_len are passed in by user
   auto long length, free_space;
   auto SSL_Write_State_t* wr_state;

   _ssl_assert(state != NULL);

   if(!_ssl_is_valid_io_state(state)) {
		return 0;
	}

	wr_state = state->write_state;

   length = data_len;

   free_space = 0; // Assume no free space to begin with, so the reserve space
   					 // check will then always reserve the maximum reserve space,
                   // reducing the possibility of deadlock (too many bytes in
                   // buffer, so cannot add header and MAC, then no record
                   // can be created, so no bytes can be sent --> deadlock)


   // If there is no data, adjust the end_data pointer by header reserve bytes
	if(wr_state->end_data == wr_state->start_data) {
		wr_state->end_data += wr_state->header_reserve;
   }

   // Freespace refers to the amount of space left over in the buffer _after_
   // the bytes we are trying to write are written. The free space is actually
   // used to determine whether length needs to be adjusted to allow space
   // for the SSL record footer. For this reason, all calculations of free
   // space must take into account the length of data being written.

   // See if the free space wraps, includes the case when start_enc
   // is equal to end_data (the space wraps the entire buffer)
   if(wr_state->start_enc < wr_state->end_data) {
   	// The free space we have will include the space at the
      // head of the buffer, since we adjust the length so that
      // we only write to the end of the buffer in this pass
      free_space = wr_state->start_enc - wr_state->write_buf;

      // See if the data is too big for the free space we have
		if((wr_state->end_write_buf - wr_state->end_data) < length) {
			// Data will wrap, so only allow write to end of buffer,
         // subsequent calls will handle the rest of the data
      	length = wr_state->end_write_buf - wr_state->end_data;
	   }
      // Free space is large enough for data
      else {
      	// Free space is space to end of buffer, plus free space
         // at head of buffer (calculated above), minus the length
         // of the data
       	free_space += wr_state->end_write_buf - wr_state->end_data - length;
      }
	}
 	// No wrap (start_enc > end_data), check free space
   else if((wr_state->start_enc - wr_state->end_data) < length) {
		// Not enough space for all the data, so adjust length
      length = wr_state->start_enc - wr_state->end_data;

      // No free space since length uses it all
      free_space = 0;
   }
   // No wrap, enough space for all data, just check reserve for footer
   else {
   	// length = data_len, from above

		// Calculate free space for reserve space calculation, make sure
      // to account for the bytes we are writing (length)
      free_space = wr_state->start_enc - wr_state->end_data - length;
   }

   // Check free space against reserved bytes, this also prevents the case
   // when end_data overlaps start_enc (implicit in free_space calcs)
   // (free_space is the space past end of data)
   if(free_space <= wr_state->footer_reserve) {
      // Our effective length is reduced so that we have at least
      // footer_reserve bytes between end_data and start_enc
      // (make free space == footer_reserve)
      length -= (wr_state->footer_reserve - free_space);
   }

   // See if after all that, we have any bytes to write
   if(length <= 0) {
   	// No bytes to write, return
    	return 0;
   }

   // Make sure length is small enough to cast
   _ssl_assert(length < MAXINT);

   // Copy data into buffer
	xmem2xmem(wr_state->end_data, data, (unsigned int)length);

   // Adjust pointers as necessary
	wr_state->end_data += length;

   if(wr_state->end_data >= wr_state->end_write_buf) {
   	// Wrap-around, restart end_data pointer at
      // beginning of buffer
   	wr_state->end_data = wr_state->write_buf;
   }

   // Cut a new record right now, but only if we wrote some data,
   // and the handshake is finished
   if(length > 0 && ssl_established(state)) {
	   ssl_create_record(state);
   }

   return (unsigned int)length;
}

/*** BeginHeader ssl_create_record */
int ssl_create_record(ssl_Socket*);
/*** EndHeader */

// This function is called by either the user or by the library to signify when
// all the input data into the write buffer should be stopped and transformed
// into a new record (to be sent later, encrypted or not)
// NOTE: THIS _FUNCTION IS NOT REENTRANT, DUE TO THE USE OF STATIC BUFFERS!
//       These buffers are made static to reduce stack usage
__SSL_DEBUG__
int ssl_create_record(ssl_Socket* state) {
   auto long length, frag_length, i, p;
   auto SSL_Record_Hdr header;
   auto SSL_ContentType rec_type;
   auto SSL_Write_State_t* wr_state;
   auto SSL_CipherState* cipher;
   auto SSL_DigestConfig* digest;
   static SSL_byte_t mac[SSL_TEMP_BUF_SIZE];
   auto int buf_size;

   auto int encrypted;			// Encryption flag
   auto int alloc_size;

   _ssl_assert(state != NULL);

   // Extract digest and cipher from TLS state
   cipher = state->cipher_state;
   digest = cipher->digest;

   alloc_size = 0;
   encrypted = 0;

	wr_state = state->write_state;

   // Depending on current state, assign record type or encryption
   switch(state->cur_state) {
   case SSL_STATE_ENC_SESS_RES:	  // Encrypted session resume (fall through)
   case SSL_STATE_ENC_HANDSHAKE:   // Encrypted handshake (fall through)
        encrypted = 1;
	case SSL_STATE_HS_LISTEN:		  // Listening for a handshake
   case SSL_STATE_HANDSHAKE:  	  // Regular handshake
   case SSL_STATE_SESSION_RESUME:  // Session resume handshake
        rec_type = SSL_REC_handshake;
   	  break;
	case SSL_STATE_SESS_RES_CH_SPEC:
	case SSL_STATE_CH_CIPHER_SPEC:
        rec_type = SSL_REC_change_cipher_spec;
   	  break;
   case SSL_STATE_APP_DATA:
        encrypted = 1;
   	  rec_type = SSL_REC_application_data;
   	  break;
   case SSL_STATE_ENC_ALERT:  	  // Send encrypted alert (fall through)
        encrypted = 1;
   case SSL_STATE_ERROR:
   case SSL_STATE_SERVER_REPLY:
        rec_type = SSL_REC_alert;  // Send alert
		  break;
   case SSL_STATE_SSL2_HANDSHAKE:  // SSLv2 Handshake (shoudnt happen)
   default:
      rec_type = SSL_REC_alert;
   	SSL_error(state, SSL_INT_STATE_ERROR);
      goto _ssl_create_rec_error;
   } // End switch

   length = 0;

   // First, calculate the length of the record
   if(wr_state->end_data > wr_state->start_data) {
    	// No wrap, simple subtract
      length = wr_state->end_data - wr_state->start_data;
   }
   else {
    	length = wr_state->end_write_buf - wr_state->start_data;
      length += (wr_state->end_data - wr_state->write_buf);
   }

   // Remove header reserve space from length
   length -= wr_state->header_reserve;

   // Build the header (we need these values for the MAC)
   header.rec_type = rec_type;
   header.length = htons((int)length);

   // Set the protocol version
	if(state->is_ssl_v3) {
		header.version.major = SSL3_VER_MAJ;
		header.version.minor = SSL3_VER_MIN;
   }
   else {
		header.version.major = TLS1_VER_MAJ;
		header.version.minor = TLS1_VER_MIN;
   }

   // Adjust start_data pointer for digest and encryption
   if(wr_state->start_data + wr_state->header_reserve <=
      wr_state->end_write_buf)
   {
	   wr_state->start_data += wr_state->header_reserve;
   }
   else {
   	// The header reserve space wraps, adjust start_data pointer
      frag_length = wr_state->end_write_buf - wr_state->start_data;
      frag_length = wr_state->header_reserve - frag_length;
      wr_state->start_data = wr_state->write_buf + frag_length;
   }

   // Assert that our write buffer is within acceptable parameters
   _ssl_assert(wr_state->start_data >= wr_state->write_buf);
   _ssl_assert(wr_state->start_data <= wr_state->end_write_buf);

#if _SSL_PRINTF_DEBUG
		printf("-------------- F A S T  S E N D -------------------\n");
   	printf("Sending %d bytes\n", (int)(length));
		if(encrypted) {
			printf("Mac Secret:\n");
	      print_bytes(cipher->server_mac_sec, cipher->server_mac_sec_size);
			printf("\nSequence number:\n");
      	print_bytes((SSL_byte_t*)&cipher->seq_number, SSL_SEQ_NUM_SIZE);
      }
  		printf("\nRecord header:\n");
      print_bytes((SSL_byte_t*)&header, sizeof(SSL_Record_Hdr));
  		printf("\nRecord data:\n");

	   if(wr_state->start_data <= wr_state->end_data) {
	      // No wrap, just go
		   print_xbytes(wr_state->start_data, (int)length);
	   }
	   else {
	      // We have a wrap, fragment encryption
	      frag_length = wr_state->end_write_buf - wr_state->start_data;
		   print_xbytes(wr_state->start_data, (unsigned int)frag_length);
   	   print_xbytes(wr_state->write_buf, (int)(length - frag_length));
	   }

		if(encrypted) {
			printf("\nRecord MAC:\n");
   	   print_bytes(mac, digest->hash_size);
      }
		printf("\n-------------------------------------------------\n");
#endif

   // Only generate MAC and encrypt if in encrypted mode
   if(encrypted) {

      // ===== generate MAC at end of data =====
	   _ssl_gen_mac(state, mac, &header, SSL_MAC_SEND);

	   // check for potential overlap for mac
      // this is where the footer_reserve space is used. Note that the hash
      // may actually be smaller than the reserve space, this is fine, though,
      // since the pointer is actually updated with the hash size.
	   if((wr_state->end_data + digest->hash_size) <= wr_state->end_write_buf)
      {
      	// Assertions
	      _ssl_assert(digest->hash_size <= sizeof(mac));

      	// Copy the mac to the buffer in one pass
         root2xmem(wr_state->end_data, &mac[0], digest->hash_size);

         // Update pointer to end of record (after MAC)
	      wr_state->end_data += digest->hash_size;
	   }
	   else {
	      // Copy MAC in two passes
	      frag_length =  wr_state->end_write_buf - wr_state->end_data;

         // Assertion for buffer length
         _ssl_assert(frag_length > 0);      // Make sure calculation is right
         _ssl_assert(frag_length < sizeof(mac));

			root2xmem(wr_state->end_data, &mac[0], (unsigned int)frag_length);
	      root2xmem(wr_state->write_buf, &mac[(unsigned int)frag_length],
                   digest->hash_size - (int)frag_length);

         // Update pointer to end of record (after MAC)
	      wr_state->end_data = wr_state->write_buf +
	                           (digest->hash_size - frag_length);
	   }

	   // Assert that our write buffer is within acceptable parameters
   	_ssl_assert(wr_state->end_data >= wr_state->write_buf);
	   _ssl_assert(wr_state->end_data <= wr_state->end_write_buf);

     	// Adjust length of record to include MAC and block cipher padding
	   length += digest->hash_size;
      // DEVIDEA: When we implement block ciphers, this will need to be
      // added in
      // length += cipher->block_size;

	   // ===== Encrypt data and MAC in place =====
      // DEVIDEA: This simple code is going to become complex when we add
      // block cipher support, since we will have to account for blocks
      // The wrap case may need 3 passes, the second being a single block
      // that overlaps the end of the buffer
	   if(wr_state->start_data <= wr_state->end_data) {
		   // Assert before casting
		   _ssl_assert(length < MAXINT);

	      // No wrap, just go
	      _ssl_encrypt_record_in_place(state, wr_state->start_data, (int)length);
	   }
	   else {
	      // We have a wrap, fragment encryption
	      frag_length = wr_state->end_write_buf - wr_state->start_data;

         // Make sure calculation is correct
         _ssl_assert(frag_length >= 0);

	      _ssl_encrypt_record_in_place(state, wr_state->start_data,
                                      (unsigned int)frag_length);
	      _ssl_encrypt_record_in_place(state, wr_state->write_buf,
                                      (int)(length - frag_length));
	   }

      // Increment sequence number
      if(_ssl_increment_seq(state, cipher->seq_number)) {
      	// Error, sequence number overflow, SSL_errno set
         // by _ssl_increment_seq
       	return 1;
      }
   }

   // ===== Add header to beginning of data =====

   // Adjust start_data pointer after digest and encryption
   if(wr_state->start_data - wr_state->header_reserve >= wr_state->write_buf) {
	   wr_state->start_data -= wr_state->header_reserve;
   }
   else {
      // We have a wrap, adjust
      frag_length = wr_state->start_data - wr_state->write_buf;
      frag_length = wr_state->header_reserve - frag_length;
      wr_state->start_data = wr_state->end_write_buf - frag_length;
   }

   // Assert that our write buffer is within acceptable parameters
   _ssl_assert(wr_state->start_data >= wr_state->write_buf);
	_ssl_assert(wr_state->start_data <= wr_state->end_write_buf);

   // Adjust the header length to reflect any changes
   header.length = htons((int)length);

   // use reserved space (size = wr_state->header_reserve)
   // NOTE: This only works because the header is a fixed size
   if(wr_state->start_data + wr_state->header_reserve <=
      wr_state->end_write_buf)
   {
   	_ssl_assert((unsigned int)wr_state->header_reserve <= sizeof(header));

   	// No wrap, just copy
   	root2xmem(wr_state->start_data, &header,
                (unsigned int)wr_state->header_reserve);
   }
   else {
    	// Overlap, fragment header
      frag_length = wr_state->end_write_buf - wr_state->start_data;

      // Assertion for buffer length
      _ssl_assert(frag_length > 0);      // Make sure calculation is right
      _ssl_assert(frag_length <= sizeof(header));

   	root2xmem(wr_state->start_data, &header, (int)frag_length);
     	root2xmem(wr_state->write_buf, ((char*)&header) + (int)frag_length,
                (unsigned int)(wr_state->header_reserve - frag_length));
   }

   // ===== Adjust pointers =====
   // Do not adjust start_enc here, will be taken care of in tick function
   // Move start_data to end of processed data
   wr_state->start_data = wr_state->end_data;

   // Adjust end_data by offset of header_reserve bytes from start_data
   if(wr_state->start_data + wr_state->header_reserve <
      wr_state->end_write_buf)
   {
   	// No wrap, just add
    	wr_state->end_data += wr_state->header_reserve;
   }
   else {
		// Need to move pointer to start of buffer, plus the difference
      // between the space after start_data and the header_reserve size
      frag_length = wr_state->end_write_buf - wr_state->start_data;
      frag_length = wr_state->header_reserve - frag_length;
      wr_state->end_data = wr_state->write_buf + frag_length;
   }

   // Assert that our write buffer is within acceptable parameters
   _ssl_assert(wr_state->end_data >= wr_state->write_buf);
	_ssl_assert(wr_state->end_data <= wr_state->end_write_buf);

   // Sucess, we created a record
   return 0;

_ssl_create_rec_error:
	state->cur_state = SSL_STATE_ERROR;
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
// SSL Communication Functions (read)
// Note that SSL *requires* a reliable transport layer, such as TCP,
// or it will not work (UDP is not an option with SSL)
// The non-blocking reads utilize a circular buffer, which is filled
// by _ssl_read_tick (below), and can be accessed using _ssl_rbuf_xread
// and _ssl_rbuf_delete. _ssl_bytesready will return the number of
// available decrypted bytes in the read buffer.
////////////////////////////////////////////////////////////////////////////////

// These functions support the circular xmem read buffer for functions
// like ssl_xfastread and ssl_gets

/*** BeginHeader _ssl_rbuf_xread */
int _ssl_rbuf_xread(SSL_Read_State_t* rd_state, long data, int length);
/*** EndHeader */

// Read data from an SSL read buffer into an xmem buffer
// returns number of bytes actually read
//
// Parameter 1: Pointer to SSL read state
// Parameter 2: Pointer to return buffer (in xmem)
// Parameter 3: The number of bytes to read
//
// Returns: The number of bytes actually read (may be 0)
__SSL_DEBUG__
int _ssl_rbuf_xread(SSL_Read_State_t* rd_state, long data, int length) {
   auto int data_len;
   auto int frag_len;
   auto long dp;

   _ssl_assert(rd_state != NULL);

   // See how many bytes we can read. ssl_bytesready takes
   // care of checking for wrapping
	data_len = _ssl_bytesready(rd_state);

   if(data_len > length) {
 		data_len = length;
   }

   if(data_len > 0) {
   	// Check for wrapping
      if(rd_state->start_dec > rd_state->start_enc) {
#if _SSL_PRINTF_DEBUG
          printf("\n_ssl_rbuf_xread: OVERLAP\n");
#endif
      	frag_len = (int)(rd_state->end_read_buf - rd_state->start_dec);

         if(frag_len >= data_len) {
         	// Data wraps, but the length requested fits in the space
            // at the end of the buffer, so just do a normal copy
	         if (data) xmem2xmem(data, rd_state->start_dec, data_len);
         }
			else {
         	// We have a wrap (frag_len < data_len) so do 2-part copy
            // Copy from end of buffer
	         if (data) xmem2xmem(data, rd_state->start_dec, frag_len);
            dp = (data + frag_len);

		      // Copy from start of buffer
      	   frag_len = data_len - frag_len;
  				if (data) xmem2xmem(dp, rd_state->read_buf, frag_len);
         }
		}
      // No wrap, just copy (common case)
      else {
  		 	// Copy the data to the caller's buffer, update the pointer
	  		if (data) xmem2xmem(data, rd_state->start_dec, data_len);
      }
   }
   else {
   	// data_len might be -1, so set to 0
   	data_len = 0;
   }

   return data_len;
}

/*** BeginHeader _ssl_rbuf_delete */
int _ssl_rbuf_delete(SSL_Read_State_t* rd_state, int data_len);
/*** EndHeader */

// Delete an amounnt of data from an SSL read buffer from the current
// start of decrypted data by updating the read pointers
//
// Parameter 1: Pointer to SSL read state
// Parameter 2: length of data to remove from buffer
//
// Returns the length of data removed
__SSL_DEBUG__
int _ssl_rbuf_delete(SSL_Read_State_t* rd_state, int data_len) {
   auto int frag_len;

   _ssl_assert(rd_state != NULL);

   // Remove the line from the buffer
   if(rd_state->start_dec > rd_state->start_enc) {
      frag_len = (int)(rd_state->end_read_buf - rd_state->start_dec);

      if(frag_len >= data_len) {
         // Update the read pointer
         rd_state->start_dec += data_len;
      }
      else {
         // Copy from start of buffer
         frag_len = data_len - frag_len;

         // Update Pointer
         rd_state->start_dec = rd_state->read_buf + frag_len;
      }
      // Assertions
		_ssl_assert(rd_state->start_dec >= rd_state->read_buf);
	   _ssl_assert(rd_state->start_dec <= rd_state->end_read_buf);
   }
   // No wrap (common case)
   else {
      // Update the read pointer
      rd_state->start_dec += data_len;

 		// Assertion - the start dec value must be before the end of the buffer
      _ssl_assert(rd_state->start_dec <= rd_state->end_read_buf);
   }

 	return data_len;
}


/*** BeginHeader _ssl_rbuf_findchar */
int _ssl_rbuf_findchar(SSL_Read_State_t* rd_state, char ch, word len,
                       word ioffs);
/*** EndHeader */

// This function looks for a particular character in the current read
// buffer and returns the length of the data up to that character.
//
// Parameter 1: Pointer to the read state
// Parameter 2: The character to search for
// Parameter 3: The maxumum number of characters to search
// Parateter 4: Offset into decrypted data where to start search
//
// Returns the length of data up to the character, -1 if that character
// is not found in length bytes
__SSL_DEBUG__
int _ssl_rbuf_findchar(SSL_Read_State_t* rd_state, char ch, word len, word ioffs)
{
	auto word bufremain;
	auto long addr, begin;

   _ssl_assert(rd_state != NULL);

   bufremain = _ssl_bytesready(rd_state);
   if (ioffs >= bufremain || (int)len <= 0)
   	return -1;	// Couldn't be found
   if (ioffs + len > bufremain)
   	len = bufremain - ioffs;

	if (rd_state->start_dec > rd_state->start_enc)
   	bufremain = (word)(rd_state->end_read_buf - rd_state->start_dec);

	begin = rd_state->start_dec;
	if (len+ioffs <= bufremain) {
   	// Only need to search first part of buffer
		if (addr = xmemchr(begin+ioffs, ch, len))
			return (int)(addr - begin);
	}
   else if (ioffs >= bufremain) {
   	// Only search second part of buffer
      ioffs -= bufremain;
      if (addr = xmemchr(rd_state->read_buf + ioffs, ch, len))
         return (int)((word)(addr - rd_state->read_buf) + bufremain);
   }
	else {
   	// Need to search both parts
		if (addr = xmemchr(begin+ioffs, ch, bufremain-ioffs))
			return (int)(addr - begin);
		else if (addr = xmemchr(rd_state->read_buf, ch, len - (bufremain-ioffs)))
			return (int)((word)(addr - rd_state->read_buf) + bufremain);
	}
   return -1;
}


/*** BeginHeader _ssl_rbuf_findmem */
int _ssl_rbuf_findmem(ssl_Socket* state, char* str, word* slenp,
                      word len, word ioffs);
/*** EndHeader */

// Find a sequence of bytes in the SSL read circular buffer that matches
// some input string. The function will do a partial match if a full
// match is not available
// PARAMETER 1: SSL state pointer
// PARAMETER 2: The string we are looking for
// PARAMETER 3: The length of the string
// PARAMETER 4: The range in which to search for the string
// PARAMETER 5: The position in the read buffer (unencrypted data) at which to
//              start searching
// Return Value: -1 if no match, else the position of the first character of
//               the string
__SSL_DEBUG__
int _ssl_rbuf_findmem(ssl_Socket* state, char* str, word* slenp,
                      word len, word ioffs)
{
	auto word slen, bufremain, temp_len;
   auto int pos;
   auto int bytes_ready, frag_len;
	auto SSL_Read_State_t* rd_state;

   rd_state = state->read_state;

   // What is the length of the string we are searching for?
   slen = *slenp;

   bytes_ready = _ssl_bytesready(rd_state);

   // Loop over buffer
	while ((int)len > 0 &&
          (pos = _ssl_rbuf_findchar(rd_state, str[0], len, ioffs)) >= 0)
   {
		// String is only a character long, return the character's position
   	if(slen == 1) {
      	return pos;
      }

      // See how many bytes we have left to read (use public API
      // ssl_bytesready so we only have bytes if in APP_DATA mode)
      temp_len = bytes_ready - pos;
		if(slen > temp_len) {
      	// Our string is longer than the number of bytes left,
         // so use buffer bytes remaining
      	*slenp = temp_len;
      }
      else {
      	// There are more bytes to read than in our string,
         // so use the length of the string
      	temp_len = slen;
      }

	   // Check for wrapping
	   if(rd_state->start_dec > rd_state->start_enc) {
	      // Do compare over end of buffer,
         // frag_len = the number of bytes between the position of the found
         //            character (pos) and the end of the buffer
	      frag_len = (int)(rd_state->end_read_buf - rd_state->start_dec) - pos;

	      if(frag_len >= temp_len) {
	         // Data wraps, but the length of the string fits in the space
	         // at the end of the buffer, so just do a single compare
	         if(!xmemcmp(rd_state->start_dec + pos, str, temp_len)) {
             	return pos;
            }
	      }
	      else {
	         // We have a wrap (frag_len < temp_len) so do 2-part compare
            // temp_len = length of string we are comparing
	         if (!xmemcmp(rd_state->start_dec + pos, str, frag_len) &&
	             !xmemcmp(rd_state->read_buf, str + frag_len, temp_len - frag_len))
            {
	            return pos;
            }
	      }
	   }
	   // No wrap, just compare (common case)
	   else {
	      if(!xmemcmp(rd_state->start_dec + pos, str, temp_len)) {
	         return pos;
	      }
	   }

      // Adjust length and offset
      len -= pos + 1 - ioffs;
      ioffs = pos + 1;

   } // end while

   // No match or error
	return -1;

}

/*** BeginHeader _ssl_wbuf_freespace */
long _ssl_wbuf_freespace(ssl_Socket* state);
/*** EndHeader */

// Returns the amount of free space in the current write buffer
__SSL_DEBUG__
long _ssl_wbuf_freespace(ssl_Socket* state)
{
   auto long free_space;
   auto SSL_Write_State_t* wr_state;

   _ssl_assert(state != NULL);

   if(!_ssl_is_valid_io_state(state)) {
		return 0;
	}

	wr_state = state->write_state;

   free_space = 0; // Assume no free space to begin with

   // See if the free space wraps
   if(wr_state->start_enc < wr_state->end_data) {
   	// The free space we have includes the space at the
      // head of the buffer
      free_space = wr_state->start_enc - wr_state->write_buf;
     	free_space += wr_state->end_write_buf - wr_state->end_data;
	}
   // No wrap, check reserve
   else {
		// Calculate free space for reserve space calculation
      free_space = wr_state->start_enc - wr_state->end_data;
   }

   // Subtract the header and footer reserves, so that we are
   // returning an accurate size for the free space (it is OK
   // if the value is slightly less than the actual space that
	// is available, since we need to keep space for the record
   // creation)
	free_space -= wr_state->header_reserve;
	free_space -= wr_state->footer_reserve;

   // Make sure we only return positive values
   if(free_space < 0) {
    	free_space = 0;
   }

   return free_space;
}


/*** BeginHeader _ssl_wbuf_reset */
void _ssl_wbuf_reset(ssl_Socket* state);
/*** EndHeader */

// Clears the state of the write buffer, so that any pending data to be
// sent is ignored. This is used when an alert is received, so we can
// cleanly close the connection
//
// Parameter 1: Pointer to SSL state structure
//
// Return value: None
__SSL_DEBUG__
void _ssl_wbuf_reset(ssl_Socket* state) {
   auto SSL_Write_State_t* wr_state;
   auto long write_buf;

   _ssl_assert(state != NULL);

   // Pointer to avoid indirection
   wr_state = state->write_state;

   // Since we are using this only as an rvalue, we can avoid 4 pointer
   // indirections
   write_buf = wr_state->write_buf;

	wr_state->end_write_buf = write_buf + SSL_WRITE_BUF_SIZE;
	wr_state->start_data = write_buf;
	wr_state->start_enc = write_buf;
	wr_state->end_data = write_buf;
}

/*** BeginHeader ssl_bytesready */
int ssl_bytesready(ssl_Socket* state);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_bytesready                         <SSL_COMM.LIB>

SYNTAX: int ssl_bytesready(ssl_Socket* state);

DESCRIPTION: Return the number of bytes ready to be read by any of the
             SSL read functions.

PARAMETER 1: Pointer to an SSL socket

RETURN VALUE: The number of bytes ready to read (may be 0)
              -1 on error (called too early, no SSL connection yet)

END DESCRIPTION **********************************************************/


// Public wrapper for the internal _ssl_bytesready
// Return true if there are any decrypted bytes to read using
// ssl_xfastread
// this function is simply a wrapper for the internal _ssl_bytesready,
// since we want to return -1 to the user until the connection is established.
// _ssl_bytesready is also used by the handshake processing functions
__SSL_DEBUG__
int ssl_bytesready(ssl_Socket* state) {
	auto int len;
   auto int linelen;
   auto char c;
   auto SSL_Read_State_t* rd_state;

   if(state == NULL)
   {
    	return -1;
   }

   rd_state = state->read_state;

	// Only return zero or positive if the ssl connection has been established
 	if(SSL_STATE_APP_DATA == state->cur_state) {
		len = _ssl_bytesready(rd_state);

		if(state->ssl_mode == SSL_MODE_SERVER_ASCII) {
			if(rd_state->saw_cr) {
				rd_state->saw_cr = 0;
				_ssl_rbuf_xread(rd_state, paddr(&c), 1);
				if (c == '\n' || c == '\0') {
					_ssl_rbuf_delete(rd_state, 1);
               len--;
					if (!len) {
						return -1;
					}
				}
			}

			// check for terminating \r and \n
         linelen = _ssl_rbuf_findchar(rd_state, '\r', len, 0);
			if (linelen != -1) {
				return linelen;
			}
			linelen = _ssl_rbuf_findchar(rd_state, '\n', len, 0);
			if (linelen != -1) {
				return linelen;
			}

			// check for buffer overflow: i.e. the data is as big as the
         // buffer, and we have not seen a terminator yet
			// check for lines that cannot be completed
         if(len == SSL_READ_BUF_SIZE || SSL_STATE_DONE == state->cur_state ||
            SSL_STATE_WAIT_CLOSE == state->cur_state ||
//				SSL_STATE_WC_SAVE_SESSION == state->cur_state ||
            SSL_STATE_ERROR == state->cur_state ||
            SSL_STATE_SERVER_REPLY == state->cur_state) {
				return len;
			}

			return -1;
		} else {
			return len;
		}
   }
   return -1;
}

/*** BeginHeader ssl_fastread */
int ssl_fastread(ssl_Socket*, char*, int);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_fastread                           <SSL_COMM.LIB>

SYNTAX: int ssl_fastread(ssl_Socket* state, char *data, int data_len);

DESCRIPTION: Read an ssl-record encoded chunk of data into a root buffer.
             Note that this is simply a wrapper for ssl_xfastread, and
             is non-blocking.

PARAMETER 1: ssl state (initialized)
PARAMETER 2: Pointer to data buffer (may be NULL to discard data)
PARAMETER 3: Length of data to read

RETURN VALUE: Number of bytes read, -1 on error (from ssl_xfastread)

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_fastread(ssl_Socket* state, char *data, int data_len) {

	if(state == NULL)
   {
    	return -1;
   }

   if(!_ssl_is_valid_io_state(state)) {
		return 0;
	}

   if(data_len <= 0) {
    	return 0;
   }
   return ssl_xfastread(state, data ? paddr(data) : 0L, data_len);
}

/*** BeginHeader ssl_xread */
int ssl_xread(ssl_Socket*, long, int);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_xread                              <SSL_COMM.LIB>

SYNTAX: int ssl_xread(ssl_Socket* state, long data, int data_len);

DESCRIPTION: Read an SSL-record encoded chunk of data.

             !!! THIS FUNCTION NOT CURRENTLY IMPLEMENTED !!!

				 This function reads data into an xmem buffer, allocated with
             xalloc by the caller. This function blocks.

PARAMETER 1: SSL state (initialized)
PARAMETER 2: Pointer to xmem data buffer
PARAMETER 3: Length of data to read

RETURN VALUE: Number of bytes read, -1 on error

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_xread(ssl_Socket* state, long data, int data_len) {
#error "ssl_xread is not yet implemented, used ssl_xfastread instead"
	// DEVIDEA: Make a loop with calls to ssl_xfastread
   if(!_ssl_is_valid_io_state(state)) {
		return 0;
	}
}

/*** BeginHeader ssl_xfastread */
int ssl_xfastread(ssl_Socket* state, long data, long data_len);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_xfastread                          <SSL_COMM.LIB>

SYNTAX: int ssl_xfastread(ssl_Socket* state, long data, long data_len);

DESCRIPTION: Read an SSL-record encoded chunk of data.

				 This function is the primary non-blocking SSL read function.
             This function reads data into an xmem buffer, allocated with
             xalloc by the caller. The SSL read functionality is driven
             by calling ssl_tick repeatedly.

PARAMETER 1: SSL state (initialized)
PARAMETER 2: Pointer to xmem data buffer (may be 0L to discard data)
PARAMETER 3: Length of data to read

RETURN VALUE: Number of bytes read, -1 on error

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_xfastread(ssl_Socket* state, long data, long length) {
   auto SSL_Read_State_t* rd_state; // Pointer to read state
   auto int data_len;
   auto int frag_len;

   if(state == NULL || length <= 0)
   {
   	// Error
   	return -1;
   }

   if(!_ssl_is_valid_io_state(state)) {
   	// This should not be an error, since it may be possible to call
      // this function (say in a loop) when the state is invalid, and
      // let the tick function handle the state
		return 0;
	}

   // Assign worker pointers
	rd_state = state->read_state;

   // Check the length before we cast to an integer below
	if(length > MAXINT)
   {
		length = MAXINT - 1;
   }

	// Read from the read buffer
	data_len =_ssl_rbuf_xread(rd_state, data, (int)length);
   if(data_len > 0) {
      // Update pointers
		_ssl_rbuf_delete(rd_state, data_len);
   }
   else {
   	// data_len might be -1, so set to 0
   	data_len = 0;
   }

   return data_len;
}


/*** BeginHeader ssl_gets */
int ssl_gets(ssl_Socket*, char*, int);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_gets                               <SSL_COMM.LIB>

SYNTAX: int ssl_gets(ssl_Socket* state, char* data, int data_len);

DESCRIPTION: 	Read a string from an SSL socket and replace the CR or LF
					with a '\0'.  If the string is longer than len, the string
               is null terminated and the remaining characters in the
               string are discarded.  This function is only valid for SSL
               sockets. This function is non-blocking.

PARAMETER1: 	SSL socket
PARAMETER2: 	pointer to output buffer
PARAMETER3: 	maximum length of the output buffer

RETURN VALUE:  0   if buffer is empty, or
					    if no '\r' or '\n' is read, but buffer had room *and*
					    the connection can get more data!
					> 0 is the length of the string
					-1  error

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_gets(ssl_Socket* state, char* data, int length)
{
   auto SSL_Read_State_t* rd_state; // Pointer to read state
   auto int data_len;
   auto int frag_len;
   auto char src_c;
   auto byte *nl_ptr, *cr_ptr; // Pointers to '\n' and '\r' in data buffer
   auto int bytes;

   if(length <= 0)
   {
   	// Nothing to read but theoretically we still have room
		return 0;
   }

   if(state == NULL || data == NULL)
   {
   	// No state or buffer
   	return -1;
   }

   if(!_ssl_is_valid_io_state(state)) {
		return 0;
	}

   // Assign worker pointers
	rd_state = state->read_state;

   // Find out the total amount of data available in the read buffer
   bytes = _ssl_bytesready(rd_state);

   // Cant read negative number of bytes
   if(bytes <= 0) {
    	return 0;
   }

   // See if we had a '\r' on the last call
   if(rd_state->saw_cr) {
    	// Read the next character, remove it if it's a
      // '\n' or '\0'
      rd_state->saw_cr = 0;
	   _ssl_rbuf_xread(rd_state, paddrSS(&src_c), 1);
      if(src_c == '\0' || src_c == '\n') {
	      _ssl_rbuf_delete(rd_state, 1);
         bytes--;
      }
   }

	// Read from the read buffer, data len will be the actual
   // length of the data read, even if length is greater then
   // the actual amount of data left
   length--; // Add room for the null-terminator
	data_len =_ssl_rbuf_xread(rd_state, paddr(data), length);
   data[data_len] = 0; // Null-terminate data
   if(data_len > 0) {
		// Search for CRLF
      // Code adapted from sock_gets (TCP.LIB)

	   // Zero the first occurance of \r and \n in data.
	   cr_ptr = memchr(data, '\r', data_len);
      if(cr_ptr) {
      	*cr_ptr = 0;
      }
	   nl_ptr = memchr(data, '\n', data_len);
      if(nl_ptr) {
      	*nl_ptr = 0;
      }

	   // Return if we did not find \r or \n yet, but still had room.
	   // *and* the connection can get more data!
	   if(!cr_ptr && !nl_ptr && (rd_state->start_enc != rd_state->end_enc)) {
	      data[0] = 0;
	      return 0;
	   }

	   // If we did find a terminator, then stop there.
	   if(cr_ptr || nl_ptr) {

	      // Find the length of the first line of data in dp.
         // Note: This code is taken directly from the sock_gets routine
         //       see the comments there for more information
	      data_len = (int)
	                 (((nl_ptr && cr_ptr) ?
	                 min(FP_OFF(nl_ptr), FP_OFF(cr_ptr)) :
	                 (nl_ptr ? FP_OFF(nl_ptr) : FP_OFF(cr_ptr)))
	                 - FP_OFF(data) );

	      // Add the length of the terminator character
	      data_len += 1;

	      // If \r at end of data, might get a \0 or \n in next packet
	      if(cr_ptr && (bytes == data_len)) {
	         rd_state->saw_cr = 1;
         }

		   // Remove the line from the buffer
   	   _ssl_rbuf_delete(rd_state, data_len);

	      // If there are more bytes available, read in the next
         // character and check for a second terminator
	      if(bytes > data_len) {
         	// Look ahead one character to see if we have a
            // second terminator, and remove it if necessary.
			   _ssl_rbuf_xread(rd_state, paddrSS(&src_c), 1);
            if((src_c == '\0') || (cr_ptr && src_c == '\n')) {
		   	   _ssl_rbuf_delete(rd_state, 1);
            }
         }
	   }
      else {
		   // Just remove the line from the buffer, since there was no
         // more room to read
   	   _ssl_rbuf_delete(rd_state, data_len);
      }
   }

   return data_len;
}



/*** BeginHeader ssl_sock_cmp */
int ssl_sock_cmp(ssl_Socket *state, word pos, int range,
                     void * mem, int * len);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_sock_cmp                           <SSL_COMM.LIB>

SYNTAX: int ssl_sock_cmp(ssl_Socket *state, word pos, int range,
                     void * mem, int * len);

KEYWORDS:		SSL, socket

DESCRIPTION:   Scan the data in the socket read buffer, looking for a
               binary character string.

               A partial match at the end of the available socket data
               may be returned if the socket is still able to accept
               data from the peer.

               To determine a full match, make sure that *len on return
               is equal to the desired search string length.

PARAMETER1: 	SSL socket
PARAMETER2: 	Initial position to start searching from.  0 means the first
               unread character in the socket buffer.
PARAMETER3: 	Range of positions to search:
                 -1: search all available data, and set the return code
                     specially (see below).
                 0:  search all available data, but do not perform the
                     data availability test.
                 positive: search from 'pos' up to but not including
                     'pos'+'range'.  This refers to the first char of the
                     search string.
PARAMETER4:		Pointer to first character of string to search for.
PARAMETER5:		On entry to function: *len = length of string to search for.
               On return from function: *len will be set to the length
                  of the search string which was matched.  This may be less
                  than the entry value only if a partial match of the string
                  was found at the end of the available socket data, and
                  the socket is still able to receive more data.


RETURN VALUE:  0: string not found in specified range.
               positive: number of characters to read (using e.g.
                  ssl_xfastread) so that the FIRST character of the search
                  string which matched would be the last character read.
               -1: this is only set if 'range' parameter is -1.  It means
                  that the string was not found, and the string could
                  never be found because the peer has closed the socket
                  and no more data will be forthcoming.

SEE ALSO:      ssl_xfastread

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_sock_cmp(ssl_Socket *state, word pos, int range,
                     void * mem, int * len)
{
	auto int rc, r;
   auto int bytes_ready;

   // See how many bytes we have to read
   bytes_ready = _ssl_bytesready(state->read_state);

   // Get our search range
   if (range <= 0 || range >= bytes_ready) {
   	r = bytes_ready;
   }
   else {
   	r = range;
   }

   // Search the buffer for the string in mem
	rc = _ssl_rbuf_findmem(state, (char *)mem, (word *)len, r, pos);

   if (rc < 0 && range < 0 &&
		 (state->cur_state == SSL_STATE_ERROR ||
		  state->cur_state == SSL_STATE_WAIT_CLOSE ||
//		  state->cur_state == SSL_STATE_WC_SAVE_SESSION ||
		  state->cur_state == SSL_STATE_DONE))
   {
   	// The socket has been closed and our range is negative, and there is
      // no match
   	rc = -1;
   }
   else if (rc < 0) {
   	// The string was not found
   	rc = 0;
   }
   else {
   	// Increment the number of characters to read by one
   	++rc;
   }

   return rc;
}

/*** BeginHeader ssl_writable */
int ssl_writable(ssl_Socket* state);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_writable                           <SSL_COMM.LIB>

SYNTAX: int ssl_writable(ssl_Socket* state);

KEYWORDS:		SSL, socket

DESCRIPTION: 	This function determines whether an SSL socket may have
					data written to it using (e.g.) ssl_fastwrite() or
               ssl_xfastwrite.

               The parameter may only be and SSL_socket.

               The return value is more than a simple boolean: it also
               indicates the amount of data the socket is guaranteed
               to accept with an ssl_xfastwrite() call that immediately
               follows.

PARAMETER1: 	ssl_Socket pointer.

RETURN VALUE:  0: socket is not writable.  It was closed by the
                  application or it may have been aborted by the peer.
               non-zero: the socket is writable.  The amount of data
                  that the socket would accept is this value minus 1;
                  which may turn out to be zero if the socket's buffer
                  is temporarily full.  On a freshly-established socket,
                  and at any other time when all data has been
                  acknowledged by the peer, the return value (minus one)
                  indicates the maximum socket transmit buffer size.

SEE ALSO:      ssl_listen, ssl_close, ssl_abort, ssl_tick, ssl_readable

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_writable(ssl_Socket* state)
{
	auto int retval;

	if(state->cur_state != SSL_STATE_APP_DATA) {
   	// Unless we are in APP_DATA mode, we cannot write to the SSL socket
      retval = 0;
   }
   else {
		// In APP_DATA mode, we can write to the socket, so return how
      // much space is left in the write buffer
		retval = (int)_ssl_wbuf_freespace(state) + 1;
   }

   return retval;
}


/*** BeginHeader ssl_readable */
int ssl_readable(ssl_Socket* state);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
ssl_readable                               <SSL_COMM.LIB>

SYNTAX: int ssl_readable(ssl_Socket* state);

KEYWORDS:		SSL, socket

DESCRIPTION: 	This function determines whether an SSL socket may have
					data read from it using (e.g.) ssl_xfastread().

               The parameter may only be an SSL socket.

               The return value is more than a simple boolean: it also
               indicates the amount of data the socket is guaranteed
               to deliver with an ssl_xfastread() call that immediately
               follows (provided that the buffer length is at least that
               long).

PARAMETER1: 	ssl_Socket pointer.

RETURN VALUE:  0: socket is not readable.  It was aborted by the
                  application or the peer has closed the socket and all
                  pending data has been read by the application.  This
                  can be used as a definitive "EOF" indication for a
                  receive stream.
               non-zero: the socket is readable.  The amount of data that
                  the socket would deliver is this value minus 1; which
                  may turn out to be zero if the socket's buffer is
                  temporarily empty, or the socket is not yet connected
                  to a peer.

SEE ALSO:      ssl_listen, ssl_close, ssl_abort, ssl_tick, ssl_writeable

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int ssl_readable(ssl_Socket* state)
{
	auto int retval;
   auto int bytesready;

   // See how many bytes are currently ready
   // We want to use the internal _ssl_bytesready function instead of
   // the public SSL API ssl_bytesready, since the API function will return
   // different values depending on the current state of the SSL socket
	bytesready = _ssl_bytesready(state->read_state);

	if(bytesready > 0 && state->cur_state == SSL_STATE_APP_DATA) {
		// There are some bytes ready, so return how many bytes we can read
		retval = bytesready + 1;
   }
   else if(state->cur_state == SSL_STATE_ERROR ||
			  state->cur_state == SSL_STATE_WAIT_CLOSE ||
//			  state->cur_state == SSL_STATE_WC_SAVE_SESSION ||
			  state->cur_state == SSL_STATE_DONE)
   {
		// Socket has been closed, waiting for a close_notify, or error
      retval = 0;
   }
   else {
	   // Readable, but no data currently (in handshake, or no data ready)
    	retval = 1;
   }

   return retval;
}

////////////////////////////////////////////////////////////////////////////////
// SSL internals (tick functions)
////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader _ssl_bytesready */
int _ssl_bytesready(SSL_Read_State_t* rd_state);
/*** EndHeader */

// Return true if there are any decrypted bytes to read using
// ssl_xfastread
__SSL_DEBUG__
int _ssl_bytesready(SSL_Read_State_t* rd_state) {
   auto int data_len;

   _ssl_assert(rd_state != NULL);

   data_len = 0;

   if(rd_state->start_dec != rd_state->start_enc) {
   	// We have some decrypted data we can give the user
      if(rd_state->start_dec > rd_state->start_enc) {
      	// start_enc has wrapped, so check against end of buffer data_len is
         // the number of bytes between the start of decrypted data and the end
         // of the read buffer, plus the number of bytes at the start of the
         // buffer
         data_len = (int)(rd_state->end_read_buf - rd_state->start_dec);
         data_len += (int)(rd_state->start_enc - rd_state->read_buf);
		}
    	// No wrap to worry about, so just subtract
		else { //if(rd_state->start_dec >= rd_state->start_enc) {
      	// data_len is the number of decrypted bytes left to read
      	data_len = (int)(rd_state->start_enc - rd_state->start_dec);
      }
   }
   else {
   	// Return -1 if no bytes are ready
    	data_len = -1;
   }

   return data_len;
}

/*** BeginHeader _ssl_handshake_tick */
int _ssl_handshake_tick(ssl_Socket*);
/*** EndHeader */

// Handshake tick function
__SSL_DEBUG__
int _ssl_handshake_tick(ssl_Socket* state) {
	auto SSL_Handshake_Hdr_t header; // Handshake message header
   auto int bytes_read; 				// Number of bytes read
   auto long xbuf;						// Pointer to xmem workspace
   auto int sess_res; 					// Session resume flag for state machine
   auto int alloc_size;					// Save how much we allocated
   auto int bytes_to_read;				// Number of available bytes to read

   _ssl_assert(state != NULL);

   // Get the number of bytes to read, if this is non-zero,
   // then we have a complete record
   // Use internal bytes ready (ssl_bytesready will return 0 unless the
   // SSL connection has been established)
   bytes_to_read = _ssl_bytesready(state->read_state);

   // If there are no bytes ready, or an error has occured with the
   // connection, simply return
   if(bytes_to_read <= 0 || SSL_STATE_ERROR == state->cur_state ||
      SSL_STATE_SERVER_REPLY == state->cur_state)
   {
		return 0;
   }

   alloc_size = 0;

	// Allocate xmem buffer space
   xbuf = _ssl_alloc(state, bytes_to_read);
   alloc_size += bytes_to_read;
   if(!xbuf) {
    	// Allocated 0 bytes, errno set by _ssl_alloc
		goto _ssl_handshake_tick_error;
   }

   // Read in the record header to get length
   bytes_read = 0;

   xmemset(xbuf, 0, bytes_to_read);

   // Read in the entire handshake message (extract from record)
   bytes_read = ssl_xfastread(state, xbuf, bytes_to_read);

   // We should always get a number of bytes equal to the
   // number we request here, since bytes_to_read is the return
   // value from _ssl_bytesready
   if(bytes_read < 0 || bytes_read != bytes_to_read) {
	   // Some kind of error occured in read, so send fatal alert and exit
      SSL_error(state, SSL_TICK_READ_ERROR);
      goto _ssl_handshake_tick_error;
   }
   else if(SSL_STATE_HS_LISTEN == state->cur_state) {
   	// We were listening for a handshake, but now we have received
      // a message, so move to the handshake state
    	state->cur_state = SSL_STATE_HANDSHAKE;
   }

   // See if we received a ChangeCipherSpec message (the CH_CIPHER_STATE
   // state is set in the record layer in ssl_read)
   if(SSL_STATE_CH_CIPHER_SPEC == state->cur_state) {
#if _SSL_PRINTF_DEBUG
      printf("--->Received ChangeCipherSpec Message<---\n");
#endif
      // Change to encrypted handshake state
      state->cur_state = SSL_STATE_ENC_HANDSHAKE;

      // Ignore the ChangeCipherSpec message in handshake processing
	}
	else if(SSL_STATE_SESS_RES_CH_SPEC == state->cur_state) {
#if _SSL_PRINTF_DEBUG
      printf("--->Received ChangeCipherSpec Message<---\n");
#endif
      // Switch to encrypted session resume state, we need to read
      // more messages, which are now encrypted
      state->cur_state = SSL_STATE_ENC_SESS_RES;

      // Ignore the ChangeCipherSpec message in handshake processing
   }
   else if(SSL_STATE_SSL2_HANDSHAKE == state->cur_state) {
      // We read an SSLv2 message, handle appropriately
      if(SSLv2_Handshake(state, xbuf, bytes_read)) {
         SSL_error(state, SSL_SSLv2_HANDSHAKE_FAIL);
         goto _ssl_handshake_tick_error;
      }
   }
   else {
      // ssl_read handles getting the appropriate amount of data
      // so if bytes_read is not equal to the number of bytes
      // requested, there was an error
      // Not enough data read, or other error (other alerts sent
      // by ssl_read)
      if(bytes_read < sizeof(SSL_Handshake_Hdr_t)) {
         if(bytes_read > 0) {
            // Only set the errno if there was no error in the read,
            // this means that there is some internal error. For read
            // errors, the errno is set be ssl_read
            SSL_error(state, SSL_TICK_READ_ERROR);
         }
         else {
	         // Need to send alert at this point
            SSL_error(state, SSL_TICK_READ_INT_ERR);
      	}
         goto _ssl_handshake_tick_error;
      }

      // Assign fields of Handshake message
      xmem2root(&header, xbuf, sizeof(SSL_Handshake_Hdr_t));

      // Process the handshake message (body begins at point where
      // header ends in xbuf)
      if(SSL_handshake(state, &header, (xbuf + sizeof(SSL_Handshake_Hdr_t)))) {
         // Some handshake failure occured (check errno)
         goto _ssl_handshake_tick_error;
      }
   }

	// Free all space used
	_ssl_free(state, alloc_size);

  	// Success!
   return 1;

	// If we get here, we have failed

_ssl_handshake_tick_error:
	// Free all space used
	_ssl_free(state, alloc_size);
	state->cur_state = SSL_STATE_ERROR;
	return 0;

}

/*** BeginHeader _ssl_bytes_to_write */
int _ssl_bytes_to_write(ssl_Socket*);
/*** EndHeader */

// This function is used to determine if there is any data left
// in the write buffer, mainly for use in determining when the
// connection should be closed.
__SSL_DEBUG__
int _ssl_bytes_to_write(ssl_Socket* state) {
	auto long bytes_to_write;
   auto SSL_Write_State_t* wr_state;

   _ssl_assert(state != NULL);

	wr_state = state->write_state;

   // See if there is data to write
   bytes_to_write = 0;
   if(wr_state->start_enc != wr_state->start_data) {
    	// There is data, check for overlap
      if(wr_state->start_enc < wr_state->start_data) {
       	// No wrap, just subtract
         bytes_to_write = wr_state->start_data - wr_state->start_enc;
      }
      else {
       	// Data has wrapped, add up until end of buffer, then add
         // from start of buffer
         bytes_to_write = wr_state->end_write_buf - wr_state->start_enc;
         bytes_to_write += (wr_state->start_data - wr_state->write_buf);
      }
   }
   else {
    	return 0;
   }

   return (int)bytes_to_write;
}

/*** BeginHeader _ssl_write_tick */
int _ssl_write_tick(ssl_Socket*);
/*** EndHeader */

// Internal tick function for non-blocking writes

// A call to ssl_create_record will check the current state, and, if
// possible, create a new (possibly encrypted) record in place of the
// user data in the write buffer. The header is prepended to the
// beginning of the encrypted record in the space reserved in the
// preceeding call to ssl_create_record (or before the first call)

__SSL_DEBUG__
int _ssl_write_tick(ssl_Socket* state) {
	auto long bytes_to_write, bytes_written;
   auto SSL_CommConfig* comm; // A temporary pointer for communication access
   auto SSL_Write_State_t* wr_state;

   _ssl_assert(state != NULL);

	wr_state = state->write_state;
   comm = state->comm_state;

// ===== Build a new record (if applicable) =====

	// ===== Write data to socket =====

   // See if there is data to write
   bytes_to_write = bytes_written = 0;
   if(wr_state->start_enc != wr_state->start_data) {
    	// There is data, check for overlap
      if(wr_state->start_enc < wr_state->start_data) {
       	// No wrap, try to write all bytes
         bytes_to_write = wr_state->start_data - wr_state->start_enc;
      }
      else {
       	// Data has wrapped, write up until end of buffer
         bytes_to_write = wr_state->end_write_buf - wr_state->start_enc;
      }

      // Attempt the write
      bytes_written = comm->xwrite(state->sock, wr_state->start_enc,
                                   bytes_to_write);

      // Only continue if we actually wrote something
      if(bytes_written > 0) {
         // Now we can adjust start_enc with bytes_written
	      wr_state->start_enc += bytes_written;

   	   // See if we wrote up to the end of the buffer
      	if(wr_state->start_enc >= wr_state->end_write_buf) {
      		// Return the pointer to the start of the buffer
	       	wr_state->start_enc = wr_state->write_buf;
   	   }
      }
   }

   // Propagate error
   return (bytes_written >= 0);
}

/*** BeginHeader _ssl_read_tick */
int _ssl_read_tick(ssl_Socket*);
/*** EndHeader */

// Internal read tick function, this function checks the communications
// channel for available data, and fills the read buffer if necessary.
// Following the read, if an entire SSL record is available in the
// read buffer, that record is decrypted and processed.
// Returns 0 on fail (implies connection is done), non-zero on success
// This function is non-blocking
// THIS FUNCTION IS NOT RE-ENTRANT

__SSL_DEBUG__
int _ssl_read_tick(ssl_Socket* state) {
   auto SSL_CommConfig* comm; // A temporary pointer for communication access
   auto SSL_DigestConfig* digest;  	// Pointer to digest state
   auto SSL_Read_State_t* rd_state; // Pointer to read state
   auto SSL_Record_Hdr header;		// Temporary header for converting v2 to v3
   auto TLS_Alert alert;		  	   // Used to extract an alert message
	auto SSL_uint32_t bytes_to_read, bytes_read, bytes_decrypted;
   auto SSL_uint32_t header_pos, temp;
   auto SSL_byte_t overlap_check, wrap_flag;
   auto int data_len;
   auto SSL_uint16_t rec_len;
   auto long frag_length, p, i;
   auto char* hdr_ptr;

	// Root buffers for use with digests below
   static SSL_byte_t buf[SSL_TEMP_BUF_SIZE];
   static SSL_byte_t mac[SSL_TEMP_BUF_SIZE];

   auto int buf_size;
   auto int temp_len;
   auto SSL_CipherState* cipher;
   auto SSL_uint16_t content_len;

   _ssl_assert(state != NULL);

   // Assign worker pointers
   comm = state->comm_state;
   cipher = state->cipher_state;
   digest = cipher->digest;
	rd_state = state->read_state;

   // The circular read buffer is set up as follows:
   //
   //            v--start_dec                       v--end_enc
   //	+----------+-----------------+----------------+---------+
   // |          | decrypted data  | encrypted data |         |
   // +----------+-----------------+----------------+---------+
   // ^--read_buf                  ^--start_enc               ^--end_read_buf
   //
   // There is never a gap between the end of decrypted data and
   // the start of encrypted data, so these points are both tracked
   // by start_enc.
   //
   // States:
   // start_dec == start_enc  -> no decrypted data
   // start_enc == end_enc    -> no encrypted data
   // start_dec == enc_enc    -> no data, start_dec == start_enc == end_enc
   // start_dec > end_enc     -> there is a wrap-around
   // start_dec > start_enc   -> decrypted data is wrapped
   // start_enc > end_enc     -> encrypted data is wrapped
   // end_enc > start_dec && end_enc < start_enc -> ERROR, overlapped decrypted
   //                                               data

#if _SSL_PRINTF_DEBUG
   // Check for processing alert header
   if(rd_state->header.v3.rec_type == SSL_REC_alert) {
      printf("!!!Processing alert header!!!\n");
   }
#endif

// ***** Check for handshake *****
	if(state->cur_state != SSL_STATE_APP_DATA) {
   	// The handshake state machine needs exactly one record at a time, so
      // we only want to read a single record at a time. To achieve this, we
      // do this check (is there unencrypted data?). The handshake will be done
      // with the current record if there is no more unencrypted data.
      // In APP_DATA mode, we can decrypt as many records as we want at once,
      // since we no longer care about record boundaries.
    	if(rd_state->start_dec != rd_state->start_enc) {
			return 1;
      }
   }

// ***** Read from the socket *****
   // Only check for overlap if end_enc starts off less
   // than start_dec
   overlap_check = (rd_state->end_enc < rd_state->start_dec);

   // Reset bytes_remaining if needed
   if(0 == rd_state->bytes_remaining) {
   	// bytes_remaining is 0 at init, and if a record is completely read
      // it should be reset in the latter case, but this is fine, since
      // in both cases the next thing we want to read is a header
	   rd_state->bytes_remaining = sizeof(SSL_Record_Hdr);
   }

   // Try to read all bytes remaining
   bytes_to_read = rd_state->bytes_remaining;

   // Check for overlap with end of buffer
   if((rd_state->end_enc + bytes_to_read) >= rd_state->end_read_buf) {
      // We have a wrap-around, cut the data in half
      // the next half will be read in the next call
      bytes_to_read = rd_state->end_read_buf - rd_state->end_enc;
   }

   // Check for overlap with decrypted data
   if(overlap_check && (rd_state->end_enc + bytes_to_read >
      rd_state->start_dec))
   {
   	// Set bytes_to_read to the number of available bytes
      // in the buffer for reading encrypted data.
      // since we are limited by the space left
		bytes_to_read = rd_state->start_dec - rd_state->end_enc;
   }

   // Any bytes that we can read?
   if(bytes_to_read <= 0) {
   	// Nothing to read, so we can just return, since records are decrypted
      // as soon as they are read in, below
    	return 1;
   }

   // Read data into buffer at end of encrypted data
   bytes_read = 0; // 0 in case there is no data ready
   if(comm->bytesready(state->sock)) {
	   bytes_read = comm->xread(state->sock, rd_state->end_enc, bytes_to_read);
   }

   if(bytes_read > 0) {
   	// Update pointer to end of encrypted data
      if((bytes_read + rd_state->end_enc) < rd_state->end_read_buf) {
      	// We did not have a wrap-around, add bytes read
         rd_state->end_enc += bytes_read;
      }
      else {
      	// We had a wraparound, reset. We should have
         // read exactly up to the end of the read buffer
         // if we get here, so simply set to the head of the
         // buffer
       	rd_state->end_enc = rd_state->read_buf;
      }

   	// Update bytes remaining with actual bytes read
      rd_state->bytes_remaining -= bytes_read;
   }
   else if(bytes_read < 0) {
	   // Communication error
	   SSL_error(state, SSL_READ_COMM_FAIL);
	   goto _ssl_read_tick_error;
   }

// ***** Finally, see if we are ready to decrypt a record *****
   // If there are bytes remaining to read, we are not ready to
   // process the record
   if(0 == rd_state->bytes_remaining) {
      // process data according to state. Unencrypted data is passed
      // to the caller by the code above. This processes the
      // header, or decrypts and MAC checks the record that was
      // just read in

   	// Now we want to reset bytes_remaining according to the read state
      switch(rd_state->state) {
      case SSL_RDSTATE_HEADER:
      	// Process the hearder and find out the length and record type
         // Dont update start_enc, we will just read over the header
         // TLS_process_header takes care of digesting the header

			// Clear the header
         memset(&rd_state->header, 0, sizeof(SSL_Record_Hdr));

         temp = rd_state->end_read_buf - rd_state->start_enc;
         _ssl_assert(temp < MAXINT); // Check for cast below

         // Get pointer to header and check
         hdr_ptr = (char*)&rd_state->header;
         _ssl_assert(hdr_ptr != NULL);

         if(temp < sizeof(SSL_Record_Hdr)) {
          	// We have a wrap-around, adjust accordingly (do 2 copies)
            // temp should be smaller than an integer, so cast is OK

            // Read from end of buffer
            xmem2root(hdr_ptr, rd_state->start_enc, (int)temp);
            hdr_ptr += (int)temp; // Adjust pointer

            // Read from start of buffer
            xmem2root(hdr_ptr, rd_state->read_buf,
                      (sizeof(SSL_Record_Hdr) - (int)temp));
         }
         else {
          	// No wrap around, just copy header into temp directly
				xmem2root(hdr_ptr, rd_state->start_enc,
                      sizeof(SSL_Record_Hdr));
         }

         // Reset the start of encrypted data so that the header space is
         // used (the header is saved in the state, so it can be overwritten)
			rd_state->end_enc = rd_state->start_enc;

         // Check for alert header
         if(rd_state->header.v3.rec_type == SSL_REC_alert) {
#if _SSL_PRINTF_DEBUG
          	printf("!!!Received alert header!!!\n");
#endif
				// Clear the write state imediately so we dont try to write any more
            // data
            _ssl_wbuf_reset(state);
         }

         // Check for inappropriate messages
         if((state->cur_state == SSL_STATE_HANDSHAKE ||
             state->cur_state == SSL_STATE_HS_LISTEN) &&
          	SSL_REC_handshake != rd_state->header.v3.rec_type &&
            SSL_REC_change_cipher_spec != rd_state->header.v3.rec_type)
         {
	         if((rd_state->header.v2.version.major != TLS1_VER_MAJ ||
	             rd_state->header.v2.version.minor != TLS1_VER_MIN) &&
					(rd_state->header.v2.version.major != SSL3_VER_MAJ ||
	             rd_state->header.v2.version.minor != SSL3_VER_MIN))
	         {
	            SSL_error(state, SSL_READ_UNEXPECTED_MSG);
	            goto _ssl_read_tick_error;
	         }
         }

	      // Make sure this is a valid record
         // Check record version (only allow SSLv3 and TLS)
			if((rd_state->header.v3.version.major == SSL3_VER_MAJ &&
	          rd_state->header.v3.version.minor == SSL3_VER_MIN))
         {
         	// The client is SSLv3, so set the state
				state->is_ssl_v3 = 1;
	   	}
	      else if((rd_state->header.v3.version.major != TLS1_VER_MAJ ||
	               rd_state->header.v3.version.minor != TLS1_VER_MIN))
         {
	         // See if it was really a SSLv2 message
            // Check for TLS/SSLv3 in the SSLv2 header
	         if((rd_state->header.v2.version.major == SSL3_VER_MAJ &&
	             rd_state->header.v2.version.minor == SSL3_VER_MIN))
	         {
            	// Got an SSLv3 in an SSLv2 message
	            state->is_ssl_v3 = 1;
	         }
	         else if(rd_state->header.v2.version.major != TLS1_VER_MAJ ||
	                 rd_state->header.v2.version.minor != TLS1_VER_MIN)
	         {
	            SSL_error(state, SSL_READ_PROTOCOL_VER);
	            goto _ssl_read_tick_error;
	         }

	         // Copy record type into data (part of SSLv2 client
	         // hello message) and adjust data pointers accordingly
            // DEVIDEA: Should be a separate function _ssl_rbuf_write
            if(rd_state->end_enc == rd_state->end_read_buf)
            {
	            root2xmem(rd_state->read_buf, &rd_state->header.v2.rec_type, 1);
					rd_state->end_enc = rd_state->read_buf + 1;
            }
            else {
	            root2xmem(rd_state->end_enc, &rd_state->header.v2.rec_type,
	                      sizeof(SSLv2_byte_t));
	            rd_state->end_enc += sizeof(SSLv2_byte_t);
            }

            // Now copy version
            if(rd_state->end_enc + sizeof(SSLv2_ProtocolVersion) >
               rd_state->end_read_buf)
            {
					temp = rd_state->end_read_buf - rd_state->end_enc;
	            root2xmem(rd_state->end_enc, &rd_state->header.v2.version,
                         (int)temp);
	            root2xmem(rd_state->read_buf, &rd_state->header.v2.version +
                         (int)temp, sizeof(SSLv2_ProtocolVersion) - (int)temp);
					rd_state->end_enc = rd_state->read_buf +
                                   (sizeof(SSLv2_ProtocolVersion) - temp);
            }
            else {
	            root2xmem(rd_state->end_enc, &rd_state->header.v2.version,
	                      sizeof(SSLv2_ProtocolVersion));
	            rd_state->end_enc += sizeof(SSLv2_ProtocolVersion);
            }

	         // We got an SSLv2 header with a TLS protocol version
	         state->cur_state = SSL_STATE_SSL2_HANDSHAKE;
	      }

	      // Extract the length
	      if(SSL_STATE_SSL2_HANDSHAKE == state->cur_state) {
	         // SSLv2 length has the MSB (bit) set
	         rd_state->bytes_remaining =
            			ntohs(rd_state->header.v2.length) & 0x7FFF;

            // Now, convert the header to the TLS/SSLv3 style, so the record
            // read state can handle it...
            header.length = ntohs((int)rd_state->bytes_remaining);
            header.version.major = rd_state->header.v2.version.major;
				header.version.minor = rd_state->header.v2.version.minor;
            header.rec_type = rd_state->header.v2.rec_type;

	         // We have already read in the message type and version numbers,
	         // so adjust the length to reflect this fact
	         rd_state->bytes_remaining -= (sizeof(SSLv2_byte_t) +
                                          sizeof(SSLv2_ProtocolVersion));

            // Copy back into header structure (note the "v3")
				rd_state->header.v3.length = header.length;
				rd_state->header.v3.version.major = header.version.major;
				rd_state->header.v3.version.minor = header.version.minor;
				rd_state->header.v3.rec_type = header.rec_type;

	      }
	      else {
	         rd_state->bytes_remaining = ntohs(rd_state->header.v3.length);
	      }

	      // Record overflow error
	      if(rd_state->bytes_remaining > SSL_MAX_RECORD_SIZE) {
	         SSL_error(state, SSL_READ_REC_OVERFLOW);
	         goto _ssl_read_tick_error;
	      }
         /*
         else if(rd_state->bytes_remaining > SSL_MAX_RECORD_DATA_LENGTH) {
		      // Internal error, record exceeded internal length
            SSL_error(state, SSL_READ_REC_OVERFLOW_INT);
            goto _ssl_read_tick_error;
         }
         */
         else if(rd_state->bytes_remaining < 0) {
         	// Incomplete header (there was an error in reading the header)
	         SSL_error(state, SSL_READ_INCOMPLETE_HEADER);
	         goto _ssl_read_tick_error;
         }
         else if(rd_state->bytes_remaining == 0) {
         	// 0-byte record, so just return to header processing
		      rd_state->bytes_remaining = sizeof(SSL_Record_Hdr);
         }
         else {
         	// Change to record processing state, and return to user
	         rd_state->state = SSL_RDSTATE_RECORD;
         }

			break; // End read state header

      case SSL_RDSTATE_RECORD:
      	wrap_flag = rd_state->start_enc > rd_state->end_enc;
         rec_len = ntohs(rd_state->header.v3.length);
         if(wrap_flag) {
          	// We have a wrap-around, adjust accordingly
            // get the length for checking against header

            // start to end of buffer
            temp = rd_state->end_read_buf - rd_state->start_enc;

			   // Start of buffer to end
            temp += (rd_state->end_enc - rd_state->read_buf);
         }
			else {
 	        // No overlap, so length is a simple subtraction
	        temp = rd_state->end_enc - rd_state->start_enc;
         }

         // Check length of record
         if(temp != ntohs(rd_state->header.v3.length)) {
	         SSL_error(state, SSL_READ_WRONG_LENGTH);
	         goto _ssl_read_tick_error;
	      }

         // Decode the package, if needed
         if(state->cur_state == SSL_STATE_ENC_HANDSHAKE   ||
            state->cur_state == SSL_STATE_ENC_SESS_RES    ||
				state->cur_state == SSL_STATE_WAIT_CLOSE      ||
//			   state->cur_state == SSL_STATE_WC_SAVE_SESSION ||
            state->cur_state == SSL_STATE_APP_DATA        &&
            rd_state->header.v3.rec_type != SSL_REC_change_cipher_spec)
         {
         	if(wrap_flag) {
	            // DEVIDEA: We need to take into account the block size for
               // block ciphers if we have an ovelap that splits a block, we
               // should have a block-sized xmem buffer to copy the split block
               // into, and then we would do 3 decrypt cycles, one for the
               // first chunk up to the split block, the split block, and
               // finally, the chunk at the beginning of the circular buffer.

               // start to end of buffer
					temp = rd_state->end_read_buf - rd_state->start_enc;

               // Pass 1, at end of buffer
               bytes_decrypted = _ssl_decrypt_record_in_place(state,
      	      						rd_state->start_enc, (int)temp);

               // Pass 2, block that spans end of buffer
               // DEVIDEA: When we add support for block ciphers, we will
               // need to handle the case when a block spans the end of
               // the receive buffer, this pass is for that purpose
               // bytes_decrypted += _ssl_decrypt_record_in_place(...)

               // Pass 3, at start of buffer
               if((rec_len - temp) > 0) {
               	// Make sure our data will fit in the buffer
	               _ssl_assert(temp < SSL_READ_BUF_SIZE);

               	// Only do decrpytion if we have bytes to decrypt since if
                  // end_enc == read_buf then temp is equal to rec_len
						bytes_decrypted += _ssl_decrypt_record_in_place(state,
      	      						 rd_state->read_buf, (int)(rec_len - temp));
               }

            }
            else {
	            // No wrap, proceed normally
               // We have to convert the record length, since it is
   	         bytes_decrypted = _ssl_decrypt_record_in_place(state,
      	                                     rd_state->start_enc, rec_len);
            }

            // Check decryption for errors
            if(bytes_decrypted < 0) {
             	// Error in decryption (error message given by decryption
               // function above)
		         goto _ssl_read_tick_error;
            }

            // Subtract out mac length
            bytes_decrypted -= digest->hash_size;

            // Save the position of the next header (relative to the end
            // of the current record, not including the hash)
            header_pos = bytes_decrypted;

#if _SSL_PRINTF_DEBUG
				printf("Entering mac checking code\n");
#endif

	         // Generate the appropriate MAC for this socket
            _ssl_gen_mac(state, mac, &rd_state->header.v3, SSL_MAC_RECEIVE);

#if _SSL_PRINTF_DEBUG
				printf("Increment read sequence number\n");
			   print_bytes((SSL_byte_t*)&cipher->rd_seq_number, SSL_SEQ_NUM_SIZE);
            printf("\n");
#endif

            // Increment the sequence number
            if(_ssl_increment_seq(state, cipher->rd_seq_number)) {
	            // Error, sequence number overflow, TLS_errno set
	            // by _ssl_increment_seq
               goto _ssl_read_tick_error;
	         }

#if _SSL_PRINTF_DEBUG
				printf("Get actual message MAC\n");
#endif
            // Set p to get message MAC, first check for wrap
	         p = rd_state->start_enc;
            if(p + (rec_len - digest->hash_size) > rd_state->end_read_buf) {
            	frag_length = rd_state->end_read_buf - p;
               frag_length = (rec_len - digest->hash_size) - frag_length;
               p = rd_state->read_buf + frag_length;

            }
            else {
            	// No wrap, point p to the end of content (start of MAC)
					p += (rec_len - digest->hash_size);
            }

            // Use pointer p to access actual message MAC
            // First, check for wrap
            if(p + digest->hash_size > rd_state->end_read_buf) {
            	// Calculate fragment length
               frag_length = rd_state->end_read_buf - p;

            	// Make sure our fragment length is small enough to cast,
               // and we wont overflow the buffer
            	_ssl_assert(frag_length < MAXINT);
					_ssl_assert((unsigned int)frag_length <= SSL_TEMP_BUF_SIZE);
               _ssl_assert((unsigned int)frag_length <= digest->hash_size);

               // Do the copies
   	         xmem2root(buf, p, (unsigned int)frag_length);
               p = rd_state->read_buf;
               xmem2root(&buf[(int)frag_length], p,
                         (unsigned int)(digest->hash_size - frag_length));
            }
            else {
            	// Make sure we do not overflow buffer
            	_ssl_assert(digest->hash_size <= sizeof(buf));

	            // We can do one copy
   	         xmem2root(buf, p, digest->hash_size);
            }

#if _SSL_PRINTF_DEBUG
				printf("Compare MACs\n");
				printf("\n-------------------------------------------------\n");
				printf("\nReceived Record:\n");
		      print_xbytes(rd_state->start_enc, rec_len);

				printf("\nReceived Record MAC:\n");
		      print_bytes(buf, digest->hash_size);
				printf("\nGenerated Record MAC:\n");
		      print_bytes(mac, digest->hash_size);
            printf("\n-------------------------------------------------\n");
#endif

            // Compare the digest
            if(memcmp(buf, mac, digest->hash_size)) {
               // MAC compare failed
#if _SSL_PRINTF_DEBUG
            printf("MAC compare failure in ssl_read\n");
#endif
               // Allocation failure, errno set by _ssl_alloc
               SSL_error(state, SSL_BAD_RECORD_MAC);
               _ssl_free(state, digest->hash_size);
               goto _ssl_read_tick_error;
            }
         }
         else {
          	// We are reading an unencrypted message, so we must be in the
            // handshake. The start_enc pointer actually points to unencrypted
            // data, so we can simply update the pointer, and not worry about
            // any decryption
            // The position of the next header is right after the current
            // record
            header_pos = rec_len;
         }

         // Check for handshake messages in APP_DATA mode
         if(state->cur_state == SSL_STATE_APP_DATA &&
            rd_state->header.v3.rec_type == SSL_REC_handshake) {
  	            SSL_error(state, SSL_READ_UNEXPECTED_MSG);
	            goto _ssl_read_tick_error;
         }

         // See if we got an alert
         if(SSL_REC_alert == rd_state->header.v3.rec_type) {
            _ssl_rbuf_xread(rd_state, paddr((void*)&alert), sizeof(TLS_Alert));
            _ssl_rbuf_delete(rd_state, sizeof(TLS_Alert));
            if(TLS_ALRT_close_notify == alert.description) {
#if _SSL_PRINTF_DEBUG
               printf("^^^Received close_notify alert^^^\n");
#endif
					// Clear the write state, so we dont try to write anymore
               // data after the message is received, it would just be
               // ignored anyway
	            _ssl_wbuf_reset(state);

               // Set the state to finish, and save session
               state->cur_state = SSL_STATE_WAIT_CLOSE; //SSL_STATE_WC_SAVE_SESSION;

            }
            // Other alert handling, all other alerts are errors
            else {
#if _SSL_PRINTF_DEBUG
               printf("^^^Received alert. Description number: %d^^^\n",
                      alert.description);
#endif
               SSL_error(state, SSL_READ_RECEIVED_ALERT);
               TLS_alertno = alert.description;
               goto _ssl_read_tick_error;
            }
         }

         // Check for ChangeCipherSpec message
         if(SSL_REC_change_cipher_spec == rd_state->header.v3.rec_type) {
            if(SSL_STATE_HANDSHAKE == state->cur_state) {
               // Set state for handshake message handling
               state->cur_state = SSL_STATE_CH_CIPHER_SPEC;
            }
            else if(SSL_STATE_SESSION_RESUME == state->cur_state) {
               // Set state for handshake message handling
               state->cur_state = SSL_STATE_SESS_RES_CH_SPEC;
            }
            else {
               // If we receive this message in any other state,
               // it is an error
               SSL_error(state, SSL_READ_UNEXPECTED_MSG);
               goto _ssl_read_tick_error;
            }
         }

         // Move the start of encrypted data to the beginning of the
         // MAC of the record we just processed. We are done with the
         // MAC at this point, so to reclaim the buffer space (and to
         // have a seamless transistion from record to record of decrypted
         // data) we will simply allow the MAC to be overwritten.
         if((header_pos + rd_state->start_enc) >= rd_state->end_read_buf) {
            // We have a wrap, adjust by subtracting the distance from the
            // start of the data to the end of the buffer from header_pos,
            // then using header_pos as the offset from the beginning of
            // the read buffer

            // header_pos is unsigned, make sure we never underflow
            _ssl_assert(header_pos >= (rd_state->end_read_buf -
                        rd_state->start_enc));

            // Do the subtraction
            header_pos -= (rd_state->end_read_buf - rd_state->start_enc);
            rd_state->start_enc = rd_state->read_buf + header_pos;
         }
         else {
            // No wrap, just add
            rd_state->start_enc += header_pos;
         }
         // Make sure we are still within the buffer boundaries
         _ssl_assert(rd_state->start_enc >= rd_state->read_buf);
         _ssl_assert(rd_state->start_enc <= rd_state->end_read_buf);

         // We just "ate" all the encrypted data, so reset the
         // encrypted data pointer
			rd_state->end_enc = rd_state->start_enc;

      	// Time to read in another header, so set the state to read the
         // next header
			rd_state->state = SSL_RDSTATE_HEADER;

         // Bytes remaining is the number of bytes remaining to be read
         // and we want to read in an entire header
	      rd_state->bytes_remaining = sizeof(SSL_Record_Hdr);
			break;
		default:
         SSL_error(state, SSL_READ_STATE_ERROR);
         goto _ssl_read_tick_error;
      } // End switch(rd_state)

   } // End if(bytes_remaining == 0)

   // return success
   return 1;

_ssl_read_tick_error:
	// Oops, error
	state->cur_state = SSL_STATE_ERROR;
	return 0;
}

/*** BeginHeader _ssl_send_fatal_alert */
void _ssl_send_fatal_alert(ssl_Socket*, TLS_AlertDescription_t);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
_ssl_send_fatal_alert					   <SSL_COMM.LIB>

SYNTAX: void _ssl_send_fatal_alert(ssl_Socket* state,
                                  TLS_AlertDescription_t desc)

DESCRIPTION: Send a fatal alert, adjust ssl_Socket

PARAMETER 1: TLS connection state
PARAMETER 2: Alert type

RETURN VALUE: None

END DESCRIPTION **********************************************************/

// No error propagation, we want to ignore further errors when
// we are sending an alert
__SSL_DEBUG__
void _ssl_send_fatal_alert(ssl_Socket* state, TLS_AlertDescription_t desc) {

	auto TLS_Alert alert;
   auto int bytes_written;

   _ssl_assert(state != NULL);

   // Setup the alert
	alert.level = (desc == TLS_ALRT_close_notify ||
	               desc == TLS_ALRT_no_renegotiation ||
	               desc == TLS_ALRT_user_cancelled) ? TLS_warning : TLS_fatal;
   alert.description = desc;

   // Set error state so ssl_write sends the correct record type
   if(SSL_STATE_APP_DATA == state->cur_state ||
		SSL_STATE_ENC_HANDSHAKE == state->cur_state ||
		SSL_STATE_ENC_SESS_RES == state->cur_state)
   {
	   state->cur_state = SSL_STATE_ENC_ALERT;
   }
   else {
	   state->cur_state = SSL_STATE_ERROR;
   }

   // Send the alert message
   bytes_written = ssl_xfastwrite(state, paddr((SSL_byte_t*)&alert),
                                   sizeof(TLS_Alert));
   if(bytes_written != sizeof(TLS_Alert)) {
		SSL_error(state, SSL_COULD_NOT_SEND_ALERT);
	   state->cur_state = SSL_STATE_ERROR;
      return;
   }
   else if(state->cur_state != SSL_STATE_APP_DATA) {
   	// We need to create a new record if we are not in
      // APP_DATA mode, since it is not automatically done
      // unless we are in APP_DATA mode
   	ssl_create_record(state);
   }

   // Set the state back to normal error state (SSL_STATE_ENC_ALERT is
   // only for sending encrypted alerts)
   if(TLS_ALRT_close_notify != desc) {
   	// We are not sending a close_notify alert, so this is an error state
#if _SSL_PRINTF_DEBUG
      printf("\n^^^Sending fatal alert: %d^^^\n", desc);
#endif
	   state->cur_state = SSL_STATE_ERROR;
   }
   else {
   	// We sent a close_notify alert, so kill socket
#if _SSL_PRINTF_DEBUG
		printf("\n^^^Sending close_notify^^^\n");
#endif
		// Wait for close, and save session
		state->cur_state = SSL_STATE_WAIT_CLOSE; // SSL_STATE_WC_SAVE_SESSION;
   }
}

////////////////////////////////////////////////////////////////////////////////
// SSL Record Protocol
// Build records for sending, process received records
////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader _ssl_increment_seq */
int _ssl_increment_seq(ssl_Socket*, SSL_byte_t*);
/*** EndHeader */

// Increment a sequence number. Assumes sequence number is in
// network-endian order (no conversion needed).
// Returns 0 on success, non-zero on failure
__SSL_DEBUG__
int _ssl_increment_seq(ssl_Socket* state, SSL_byte_t* seq_num) {
 	auto int i, carry;

   _ssl_assert(state != NULL);

   // Note: This is a bit of a dirty trick. The SSL sequence number
   // is an 8-byte integer that starts at 0 at the beginning of a
   // session, and counts up for each record received. The number is
   // always used in network-endian order, so we can avoid endianness
   // conversion by adding in reverse, hence the reversed loop index.
   // The algorithm works by starting with the top byte, and incrementing
   // it until the byte overflows (this is checked with the upcast to an
   // integer from a byte to set the carry value). If the byte overflows,
   // than the loop continues, and begins by incrementing the next byte
   // down. If there is no carry for any given byte, then the byte increments
   // and the function returns successfully. If we ever actually overflow
   // the entire (!) 8-byte number, we return an error.

   carry = 1;
   for(i = SSL_SEQ_NUM_SIZE-1; i > 0; i--) {
      carry = (int)seq_num[i] + 1; // Integer conversion to check for carry
      if(carry > 0xFF) {
			// We have a carry
         seq_num[i] = 0;
      }
      else {
      	seq_num[i] += 1;
         return 0;
      }
   }
   // Should never get here (means carry check passed every time, overflowing
   // the sequence number)
   SSL_error(state, SSL_SEQ_NUM_OVERFLOW);
   return 1;
}

/*** BeginHeader _ssl_encrypt_record_in_place */
int _ssl_encrypt_record_in_place(ssl_Socket*, long, SSL_uint16_t);
/*** EndHeader */

/* START _FUNCTION DESCRIPTION ********************************************
_ssl_encrypt_record_in_place				<SSL_COMM.LIB>

SYNTAX: int _ssl_encrypt_record_in_place(ssl_Socket* state, long data,
                               			 SSL_uint16_t length);

DESCRIPTION: Encrypt the payload of an SSL record using the bulk cipher.
				 Encrypts the data in place, rather than using a temporary
             buffer

PARAMETER 1: SSL state structure
PARAMETER 2: Pointer to xmem data
PARAMETER 3: Length of the data to encrypt

RETURN VALUE: Number of bytes encrypted, -1 on failure

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int _ssl_encrypt_record_in_place(ssl_Socket* state, long data,
                                 SSL_uint16_t length)
{
   auto SSL_BulkCipherConfig* bulk_cipher;
   auto int ret_val;

   _ssl_assert(state != NULL);

   // Pointer to our bulk cipher
   bulk_cipher = state->cipher_state->bulk_cipher;

   if(length > SSL_WRITE_BUF_SIZE || data == 0)
   {
   	// Set error number
   	SSL_error(state, SSL_ENCRYPTION_FAIL);
      return -1;
   }

	// NOTE: The bulk cipher algorithms should use xmem buffers
   ret_val = bulk_cipher->encrypt(&bulk_cipher->write_state,
                                  data, data, length);

   // Check for encryption errors
	if(ret_val) {
   	// Set error number
   	SSL_error(state, SSL_ENCRYPTION_FAIL);
      ret_val = -1;
   }
   else {
   	// Success
   	ret_val = length;
   }

   // Return status of encryption
   return ret_val;
}

/*** BeginHeader _ssl_decrypt_record_in_place */
int _ssl_decrypt_record_in_place(ssl_Socket* state, long data,
                                 SSL_uint16_t length);
/*** EndHeader */


/* START _FUNCTION DESCRIPTION ********************************************
_ssl_decrypt_record_in_place			   <SSL_COMM.LIB>

SYNTAX: int _ssl_decrypt_record_in_place(ssl_Socket* state, long data,
                               			 SSL_uint16_t length);

DESCRIPTION: Decrypt the payload of an SSL record using the bulk cipher.
				 This function decrypts the record in place, rather than
             using a temporary buffer.

PARAMETER 1: TLS state structure
PARAMETER 2: Data buffer, used as both input and output (in xmem)
PARAMETER 3: Length of the input data

RETURN VALUE: Number of bytes decrypted, -1 on error

END DESCRIPTION **********************************************************/

__SSL_DEBUG__
int _ssl_decrypt_record_in_place(ssl_Socket* state, long data,
                                 SSL_uint16_t length)
{
   auto SSL_BulkCipherConfig* bulk_cipher;
   auto int ret_val;

	_ssl_assert(state != NULL);

   // Pointer to our bulk cipher
   bulk_cipher = state->cipher_state->bulk_cipher;

   if(length > SSL_READ_BUF_SIZE || data == 0)
   {
   	// Set error number
   	SSL_error(state, SSL_ENCRYPTION_FAIL);
      return -1;
   }

   // Bulk encryption should use xmem buffers (hence the long addresses)
   // It should also be capable of using the input buffer as an
   // output buffer to work with this scheme
   ret_val = bulk_cipher->decrypt(&bulk_cipher->read_state, data, data, length);

   // Check decryption
   if(ret_val) {
    	SSL_error(state, SSL_DECRYPTION_FAIL);
      ret_val = -1;
   }
   else {
    	ret_val = length;
   }

   return ret_val;
}

/*** BeginHeader _ssl_gen_mac */
int _ssl_gen_mac(ssl_Socket*, char*, SSL_Record_Hdr*, _ssl_MAC_mode_t);
/*** EndHeader */

// Generate a MAC for a message (either incoming or outgoing) using the
// appropriate digest. Works for both TLS and SSLv3
// Note: The buffer mac (parameter 2) is assumed to be
// of size SSL_TEMP_BUF_SIZE

__SSL_DEBUG__
int _ssl_gen_mac(ssl_Socket* state, char* mac,
                        SSL_Record_Hdr* header, _ssl_MAC_mode_t mac_mode)
{
   auto long length, frag_length, i, p;
   auto SSL_Write_State_t* wr_state;
   auto SSL_Read_State_t* rd_state;
   auto SSL_CipherState* cipher;
   auto SSL_DigestConfig* digest;
   auto int buf_size;
   auto int temp_len;

	_ssl_assert(state != NULL);
	_ssl_assert(mac != NULL);
	_ssl_assert(header != NULL);

   // Extract digest and cipher from TLS state
   cipher = state->cipher_state;
   digest = cipher->digest;
	wr_state = state->write_state;
	rd_state = state->read_state;

   // Get the length of the record
   length = ntohs((int)header->length);

   // If generating a MAC for an incoming message, we need to subtract out
   // the length of the MAC itself from our length calculation
	if(mac_mode == SSL_MAC_RECEIVE) {
	   length -= digest->hash_size;
   }

   // TLS record MAC = Digest(mac_secret, seq_num + type + version +
   //                         length + content)
   // SSLv3 MAC = Digest(mac_secret + pad2 + Digest(mac_secret + pad1 +
   //                    seq_num + length + content)
   // The digest is HMAC for TLS, and the SSLv3 MAC for SSLv3
   // All this function does is add the seq_num through content into the hash
   // and finish the hash, the individual algorithms take care of the rest
   if(mac_mode == SSL_MAC_SEND) {
	   digest->init(&digest->state, cipher->server_mac_sec,
	                cipher->server_mac_sec_size, &cipher->seq_number,
	                SSL_SEQ_NUM_SIZE);
   }
	else {
	   digest->init(&digest->state, cipher->client_mac_sec,
	                cipher->client_mac_sec_size, &cipher->rd_seq_number,
	                SSL_SEQ_NUM_SIZE);
   }

   // Only difference between MACs for TLS and SSLv3 is the following
   // (record type and version)

	   // Add record type
	   digest->add(&digest->state, &header->rec_type,
	               sizeof(header->rec_type));

	if(!state->is_ssl_v3) {
	   // Add version
	   digest->add(&digest->state, &header->version,
	               sizeof(SSL_ProtocolVersion));
   }

   // Add length
   if(mac_mode == SSL_MAC_SEND) {
	   temp_len = header->length;
   }
   else {
   	// If receiving, we need to subtract out the hash size before the digest
		temp_len = htons(ntohs(rd_state->header.v3.length) - digest->hash_size);
   }
   digest->add(&digest->state, (char*)&temp_len, 2);

   // *** Digest Content ***
   // Finally, add the content (uses content length)
   // Copy to root buffer to use with digest, check for wrapping in
   // circular buffer
   if(mac_mode == SSL_MAC_SEND) {
	   p = wr_state->start_data;
   }
	else {
		p = rd_state->start_enc;
   }
   buf_size = SSL_TEMP_BUF_SIZE;
   for(i = 0; i < length; i += buf_size) {
      buf_size = SSL_TEMP_BUF_SIZE;

      // Adjust size of data to digest if less than buffer size
      if(((int)length - i) < SSL_TEMP_BUF_SIZE) {
         buf_size = (int)(length - i);
      }

      // Check for wrap
	   if(mac_mode == SSL_MAC_SEND) {
   	   if(p + buf_size > wr_state->end_write_buf) {
      	   buf_size = (int)(wr_state->end_write_buf - p);
	      }
      }
      else {
         if(p + buf_size > rd_state->end_read_buf) {
            buf_size = (int)(rd_state->end_read_buf - p);
         }
      }

      // Copy to root buffer for digest. Use mac buffer,
      // assumed to be of size SSL_TEMP_BUF_SIZE
      xmem2root(mac, p, (unsigned int)buf_size);
      digest->add(&digest->state, mac, buf_size);

      p += buf_size;

      // Handle wrapping
	   if(mac_mode == SSL_MAC_SEND) {
	      if(p >= wr_state->end_write_buf) {
   	      p = wr_state->write_buf;
      	}
      }
		else {
	      if(p >= rd_state->end_read_buf) {
	         p = rd_state->read_buf;
	      }
      }
   }

   // Finally, calculate the final MAC
   digest->finish(&digest->state, mac);

   return 1;
}


/*** BeginHeader */
#endif
/*** EndHeader */