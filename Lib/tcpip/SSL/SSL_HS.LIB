/*
   Copyright (c) 2015 Digi International Inc.

   This Source Code Form is subject to the terms of the Mozilla Public
   License, v. 2.0. If a copy of the MPL was not distributed with this
   file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/
/* START LIBRARY DESCRIPTION *********************************************
SSL_HS.LIB
	SSL Module, v. 1.04

DESCRIPTION: SSL handshake functions
             This library is intended to only be included by SSL.LIB
             for handshake functionality.

END DESCRIPTION **********************************************************/

/*** BeginHeader */

#ifndef __SSL_HS_LIB__
#define __SSL_HS_LIB__

/*** EndHeader */


////////////////////////////////////////////////////////////////////////////////
// SSL Handshake State machine, performs actions
// depending on the handshake message received
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////

/*** BeginHeader _ssl_digest_hs_message */
int _ssl_digest_hs_message(ssl_Socket*, SSL_Handshake_Hdr_t*, long);
/*** EndHeader */

// Digest handshake messages for finished calculation
// This function works for both TLS and SSLv3
// Return 0 on success, non-zero on failure (set SSL_errno)
// NOTE: THIS FUNCTION IS NOT REENTRANT, DUE TO THE USE OF STATIC BUFFERS!
//       These buffers are made static to reduce stack usage
__TLS_V1_DEBUG__
int _ssl_digest_hs_message(ssl_Socket* state, SSL_Handshake_Hdr_t* hs_hdr,
							 long body)
{
	auto long xbuf;
   auto unsigned long length,i;
   static SSL_byte_t buf[SSL_TEMP_BUF_SIZE];
   auto long msize;
   auto auto int alloc_size;

   _ssl_assert(state != NULL);
   _ssl_assert(hs_hdr != NULL);

   alloc_size = 0;

   // Get the message length
	length = n24toul(hs_hdr->length) - sizeof(SSL_Handshake_Hdr_t);

   // Use state workspace
   xbuf = _ssl_alloc(state, (unsigned int)length + sizeof(SSL_Handshake_Hdr_t));
   alloc_size += ((unsigned int)length + sizeof(SSL_Handshake_Hdr_t));
	if(!xbuf) {
   	// Allocation failure
		_ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }

   // Copy message into a temporary buffer
   root2xmem(xbuf, (SSL_byte_t*)hs_hdr, sizeof(SSL_Handshake_Hdr_t));
   xmem2xmem(xbuf + sizeof(SSL_Handshake_Hdr_t), body, (unsigned int)length);
   length += sizeof(SSL_Handshake_Hdr_t);

#if _SSL_PRINTF_DEBUG
   printf("\n\n%d bytes digested\n", (unsigned int)length);
	print_xbytes(xbuf, (unsigned int)length);
#endif

	// Cut up message into root buffer for digest
   for(i = 0; i < length; i += SSL_TEMP_BUF_SIZE) {
   	msize = SSL_TEMP_BUF_SIZE;
   	if(length - i < SSL_TEMP_BUF_SIZE) {
			msize = length - i;
      }
   	xmem2root(buf, xbuf + (long)i, (unsigned int)msize);

	   // Digest the message
   	md5_append(&state->fin_hash_read->md5_hash, buf, (unsigned int)msize);
	   sha_add(&state->fin_hash_read->sha_hash, buf, (unsigned int)msize);

   	// Digest for write hash too
	   md5_append(&state->fin_hash_write->md5_hash, buf, (unsigned int)msize);
   	sha_add(&state->fin_hash_write->sha_hash, buf, (unsigned int)msize);
   }

   // Free buffer
   _ssl_free(state, alloc_size);

   // Success
   return 0;
}

/*** BeginHeader SSL_handshake */
int SSL_handshake(ssl_Socket*, SSL_Handshake_Hdr_t*, long);
/*** EndHeader */

// Process a handshake message, using current state
// Returns 0 on success, non-zero on failure (sets SSL_errno)
// The header is a pointer to a root structure (for speed) and
// the body is a pointer to an xmem buffer (to save root space)
//
// The message pointers are set up to point to the input buffer, since
// they are only used temporarily within this function. This saves memory
// (message data structures use pointers, rather than arrays, so less
// stack is used) and speeds processing (no memcpys). This is a little
// dangerous, so BE CAREFUL.
__SSL_DEBUG__
int SSL_handshake(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                   long body)
{
   _ssl_assert(state != NULL);
   _ssl_assert(header != NULL);

   // To generate the correct hash for comparison with the client
   // finished verify_data, we cannot include the finished message
   // in the hash, so we will add the finish message in later.
   if(header->msg_type != finished &&
   	SSL_STATE_SSL2_HANDSHAKE != state->cur_state)
   {
	   // Digest the message
      // SSLv2 handshake messages should be digested when converted
      // in the SSLv2 ClientHello handler
	   _ssl_digest_hs_message(state, header, body);
   }

   // If processing an SSLv2 handshake message (which
   // has now been converted into a TLS message), then
   // switch to "normal" handshake mode.
   if(SSL_STATE_SSL2_HANDSHAKE == state->cur_state) {
		state->cur_state = SSL_STATE_HANDSHAKE;
   }

	switch(header->msg_type) {
	case hello_request:
		  // Not currently supported
#if _SSL_PRINTF_DEBUG
   printf("!!!  Received unsupported hello_request message !!!\n");
#endif
        break;
   case client_hello:
   	  return _ssl_do_client_hello(state, header, body);
   case server_hello:
   	  // Not currently supported, for client support only
#if _SSL_PRINTF_DEBUG
   printf("!!!  Received unsupported server_hello message !!!\n");
#endif
   	  break;
   case certificate:
   	  // Not supported, client side only
#if _SSL_PRINTF_DEBUG
   printf("!!!  Received unsupported certificate message !!!\n");
#endif
   	  break;
   case server_key_exchange:
   	  // Not supported we should not receive this kind
        // of message as a server
#if _SSL_PRINTF_DEBUG
   printf("!!!  Received unsupported server_key_exchange message !!!\n");
#endif
		  break;
   case certificate_request:
   	  // Process a certificate request
        return _ssl_do_cert_req(state, header, body);
   case server_hello_done:
   	  // Not currently a client, so will not receive
        // server hello done messages
#if _SSL_PRINTF_DEBUG
   printf("!!!  Received unsupported server_hello_done message !!!\n");
#endif
   	  break;
   case certificate_verify:
   	  // No certificate verification
#if _SSL_PRINTF_DEBUG
   printf("!!!  Received unsupported certificate_verify message !!!\n");
#endif
   	  break;
   case client_key_exchange:
   	  return _ssl_do_client_key_exch(state, header, body);
   case finished:
        return _ssl_do_hs_finish(state, header, body);
   case server_request:
   	  return _ssl_do_server_request(state, header, body);
   default:
   	  // Error, unidentified message type
#if _SSL_PRINTF_DEBUG
   printf("!!!  Received unsupported and unidentified handshake message !!!\n");
#endif
     	  break;
   }

   // Send alert, unexpected message
   SSL_error(state, SSL_HS_UNEXPECTED_MSG);
	return 1;
}

/*** BeginHeader SSLv2_Handshake */
int SSLv2_Handshake(ssl_Socket*, long, int);
/*** EndHeader */

// SSLv2 handshake handler. This function expects to receive only
// an SSLv2_ClientHello message in raw bytes (stripped of its header),
// anything else is an error
// This function simply converts the SSLv2 header into an SSLv3/TLS
// header, and continues by calling the SSL_handshake state machine
// handler.
// NOTE: THIS FUNCTION IS NOT REENTRANT, DUE TO THE USE OF STATIC BUFFERS!
//       These buffers are made static to reduce stack usage
__SSL_DEBUG__
int SSLv2_Handshake(ssl_Socket* state, long body, int msg_len) {
	auto SSL_ClientHello cli_hello;  // Message structure to build TLS message
	auto SSL_Handshake_Hdr_t header; // "Fake" header for processing with
    											//TLS_Handshake

   auto long xbuf, p;  // Buffer to build up "fake" TLS client hello
   auto long suites;   // Used to extract each 2-byte suite from 3-byte numbers
   auto long cli_rand; // Used to create client random from SSLv2 Challenge
   auto SSL_uint16_t challenge_len, suite_len, temp;
   auto SSL_uint32_t length;
   static SSL_byte_t buf[SSL_TEMP_BUF_SIZE]; // Temporary root buffer
   auto int i, j, msize;
   auto int alloc_size;

	_ssl_assert(state != NULL);

	// Since this handling is provided only to support the SSLv2 client hello,
   // we are simply going to build a SSL_ClientHello message from the
   // SSLv2 message, and proceed with the TLS initialization. The client will
   // fail out if the server hello cannot be processed (the client is actually
   // an SSLv2 client)

   // Allocate buffer
   xbuf = _ssl_alloc(state, SSL_MAX_HANDSHAKE_SIZE);
   alloc_size = SSL_MAX_HANDSHAKE_SIZE;
	if(!xbuf) {
   	// Allocation error
		_ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }

#if _SSL_PRINTF_DEBUG
   printf("--->Received SSLv2 Client Hello, Processing<---\n");
	printf("\n\n%d bytes digested\n", (unsigned int)msg_len);
	print_xbytes(body, (unsigned int)msg_len);
#endif

  length = 0;

  // Need root buffer for message digest, break body into
  // chunks copied from xmem into smaller root buffer

	// Digest the original message
   for(i = 0; i < msg_len; i += SSL_TEMP_BUF_SIZE) {
   	msize = SSL_TEMP_BUF_SIZE;
   	if(msg_len - i < SSL_TEMP_BUF_SIZE) {
			msize = msg_len - i;
      }
   	xmem2root(buf, body + (long)i, msize);

     	// Do read hash digest
      md5_append(&state->fin_hash_read->md5_hash, buf, (unsigned int)msize);
      sha_add(&state->fin_hash_read->sha_hash, buf, (unsigned int)msize);

      // Digest for write hash too
      md5_append(&state->fin_hash_write->md5_hash, buf, (unsigned int)msize);
    	sha_add(&state->fin_hash_write->sha_hash, buf, (unsigned int)msize);
   }

   // Skip the message type (shoulc be client hello)
   // DEVIDEA: Add a check of the message type here?
   body += sizeof(SSLv2_byte_t);

   // Copy the version number over to our new message
	xmem2root(&cli_hello.client_version, body, sizeof(SSL_ProtocolVersion));
   body += sizeof(SSLv2_ProtocolVersion);

//   SSLv2_uint16_t   ciphersuite_length; // Length(bytes) of ciphersuite offers
	temp = xgetint(body);
   cli_hello.ciphersuite_length = htons(temp);

   // Convert length from 3 bytes to 2 per entry: the SSLv2 ciphersuite entries
   // are 3 bytes each - the bottom 2 bytes match the SSLv3/TLS entry values.
   // We are converting to an SSLv3 record, so the length of all the cipher-
   // suites needs to be adjusted to reflect 2-byte entries. Divide by 3 to
   // get the number of entries, multiply by 2 to get number of bytes.
   suite_len = (cli_hello.ciphersuite_length / 3) * 2;
   body += sizeof(SSLv2_uint16_t);
	length += sizeof(SSLv2_uint16_t);

//   SSLv2_byte_t     session_id_length;	 // Session ID length
   body += sizeof(SSLv2_uint16_t); // Ignore session ID in SSLv2 message

//	SSLv2_uint16_t   challenge_length;   // Length(bytes) of SSLv2 challenge
	temp = xgetint(body);
	challenge_len = htons(temp);
   body += sizeof(SSLv2_uint16_t);
   length += sizeof(SSLv2_uint16_t);

//   SSLv2_byte_t*	  session_id;    		 // Session ID pointer
	cli_hello.session_id = 0;
	cli_hello.session_id_length = 0;
   length += sizeof(SSL_byte_t);

//   SSLv2_uint16_t*  cipher_suites; 		 // Ciphersuite offers
	// Process cipher suites
   suites = _ssl_alloc(state, suite_len);
   alloc_size += suite_len;
	if(!suites) {
   	// Allocation error
		_ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }

   // Cycle through SSLv2 ciphersuite offers (3 bytes per entry, hence the
   // increment of 3) and generate corresponding 2-byte entries for the
   // SSLv3/TLS record that we are generating.
   for(i = 0, j = 0; i < cli_hello.ciphersuite_length; i += 3) {
   	// Check for SSLv3/TLS suites (MSB == 0)
      // (MSB: body + i, middle byte: body + i + 1, LSB: body + i + 2)
		if((xgetint(body + i) & 0xFF00) == 0) {
      	// Copy 2 bottom bytes into the suites choice buffer
         xsetint((suites + j), xgetint((body + i + 1)));
         j += 2;
      }
   }
   // j is now the number of bytes in our new cipher offer collection

   // Advance our pointer, point to the new suite collection
   body += cli_hello.ciphersuite_length;
	cli_hello.cipher_suites = suites;

   // Now use our new length (stored in j after loop above)
   cli_hello.ciphersuite_length = htons(j);
   length += j;

//   SSLv2_byte_t*    challenge; 	  		 // SSLv2 challenge data
	// We need to convert the SSLv2 challenge data into our Random seed
   // Pad with 0's to the left (move the bytes to the furthest right they
   // can go, sizeof(SSL_Random) - challenge_len)
   cli_rand = _ssl_alloc(state, sizeof(SSL_Random));
   alloc_size += sizeof(SSL_Random);
	if(!cli_rand) {
   	// Allocation error
		_ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }
	// Clear the buffer and our random
  	memset(&cli_hello.random, 0, sizeof(SSL_Random));
  	xmemset(cli_rand, 0, sizeof(SSL_Random));
   // Copy into temp buffer, then into the client hello random
   xmem2xmem(cli_rand + (sizeof(SSL_Random) - challenge_len),
             body, challenge_len);
   xmem2root(&cli_hello.random, cli_rand, sizeof(SSL_Random));
   length += challenge_len;

#if _SSL_PRINTF_DEBUG
	printf("\n\nClient Random:\n");
	print_bytes((SSL_byte_t*)&cli_hello.random, sizeof(SSL_Random));
#endif

	// Build the header
   ulton24(header.length, length);
	header.msg_type = client_hello;

   // Build a raw buffer from the message we just created to pass to
   // SSL_handshake
   p = xbuf;

   // Client version
   root2xmem(p, &cli_hello.client_version, sizeof(SSL_ProtocolVersion));
   p += sizeof(SSL_ProtocolVersion);

   // Client random
   root2xmem(p, &cli_hello.random, sizeof(SSL_Random));
   p += sizeof(SSL_Random);

   // Session ID
   root2xmem(p, &cli_hello.session_id_length, sizeof(SSL_byte_t));
   p += sizeof(SSL_byte_t);
   if(cli_hello.session_id_length != 0) {
	   xmem2xmem(p, cli_hello.session_id, cli_hello.session_id_length);
   	p += cli_hello.session_id_length;
   }

   // Ciphersuites
   root2xmem(p, &cli_hello.ciphersuite_length, sizeof(SSL_uint16_t));
   p += sizeof(SSL_uint16_t);
   xmem2xmem(p, cli_hello.cipher_suites, ntohs(cli_hello.ciphersuite_length));
   p += cli_hello.ciphersuite_length;

   // compression methods (none, so set to null)
   xsetint(p, 0x0000);
   p += 2;

#if _SSL_PRINTF_DEBUG
   	  printf("\nTLS ClientHello built from SSLv2 ClientHello:\n");
        print_xbytes(xbuf, (unsigned int)length);
#endif

   // Do the TLS handshake
   i = SSL_handshake(state, &header, xbuf);

   _ssl_free(state, alloc_size);

   return i;
}

////////////////////////////////////////////////////////////////////////////////
// SSL Handshake Internals
////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////
// Process a hello request (?)

/*** BeginHeader _ssl_do_hello_req */
int _ssl_do_hello_req(ssl_Socket*, SSL_Handshake_Hdr_t*, long);
/*** EndHeader */

__SSL_DEBUG__
int _ssl_do_hello_req(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                       		 long body)
{
	// Not currently supported, return failure
	return 0;
}

///////////////////////////////////////////////////////
// Process a client hello

/*** BeginHeader _ssl_do_client_hello */
int _ssl_do_client_hello(ssl_Socket*, SSL_Handshake_Hdr_t*, long);
/*** EndHeader */

__SSL_DEBUG__
int _ssl_do_client_hello(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                       		 long body)
{
	// After parsing the message:
   // 1) send server hello message
   // 2) send certificate
   // 3) send server hello done message
	auto SSL_ClientHello cli_hello;
   auto int ret_val, temp;

   ret_val = 0; // Assume success

#if _SSL_PRINTF_DEBUG
   	  printf("--->Received Client Hello, begin Server Hello<---\n");
#endif

   // Parse the handshake message
   xmem2root(&cli_hello.client_version, body, sizeof(SSL_ProtocolVersion));
   body += sizeof(SSL_ProtocolVersion);

   xmem2root(&cli_hello.random, body, sizeof(SSL_Random));
   body += sizeof(SSL_Random);

   // Extract length and session id and check for illegal length
   xmem2root(&cli_hello.session_id_length, body, 1);
   if(cli_hello.session_id_length > SSL_MAX_SESSION_ID) {
   	SSL_error(state, SSL_HS_SESSION_ID_TOO_LONG);
      return 1; // Error return value
   }

	// Get session ID
	body += sizeof(SSL_byte_t);
   if(cli_hello.session_id_length > 0) {
		// Pointer to original buffer provides access without using more memory
      // (buffer is in xmem)
	   cli_hello.session_id = body;
   }
   else {
		cli_hello.session_id = 0;
   }
 	body += cli_hello.session_id_length;

   // Extract length and ciphersuites
	temp = xgetint(body);
   cli_hello.ciphersuite_length = htons(temp);
	body += sizeof(SSL_uint16_t);
   if(cli_hello.ciphersuite_length > 0) {
		// Pointer to original buffer provides access without using more memory
      // (buffer is in xmem)
	   cli_hello.cipher_suites = body;
   }
   else {
		cli_hello.cipher_suites = 0;
   }
  	body += cli_hello.ciphersuite_length;

   // Extract length and compression methods
	xmem2root(&cli_hello.compression_length, body, 1);
	body += sizeof(SSL_byte_t);
   if(cli_hello.compression_length > 0) {
		// Pointer to original buffer provides access without using more memory
      // (buffer is in xmem)
	   cli_hello.compression_methods = body;
   }
   else {
		cli_hello.compression_methods = 0;
   }
  	body += cli_hello.compression_length;

   // Check Protcol Version
   if(!(cli_hello.client_version.major == TLS1_VER_MAJ &&
        cli_hello.client_version.minor == TLS1_VER_MIN))
   {
	   //	Check for SSLv3
	   if(!(cli_hello.client_version.major == SSL3_VER_MAJ &&
   	     cli_hello.client_version.minor == SSL3_VER_MIN))
	   {
   		SSL_error(state, SSL_HS_CLI_PROTOCOL_ERROR);
	      return 1;
	   }
      else {
      	// We are now an SSLv3 server, so set the state to reflect
         // this fact
      	state->is_ssl_v3 = 1;
/* DEVIDEA: If we ever want to disable SSLv3, we will need this error
   		SSL_error(state, SSL_HS_CLI_PROTOCOL_ERROR);
	      return 1;
*/
      }
   }

   // Check session ID for resume
   if(cli_hello.session_id_length != 0) {
		// Client is attempting to resume, try to find
      // matching session ID and use that state
#if _SSL_PRINTF_DEBUG
      printf("--->Received resume session client hello.<---\n");
      printf("Session ID:\n");
      print_xbytes(cli_hello.session_id, cli_hello.session_id_length);
#endif

#if SSL_NO_SESSION_RENEGOTIATION
		SSL_error(state, SSL_HS_NO_RENEGOTIATION);
      return 1;
#else
		state->cur_state = SSL_STATE_SESSION_RESUME;
		// Session resumption is allowed, so do it (sets up state with
      // cached session information)
      if(_ssl_session_resume(state, cli_hello.session_id,
                         cli_hello.session_id_length)) {
			// We have an invalid Session ID
			goto _ssl_hs_new_session; // Start a new session

//         SSL_error(state, SSL_HS_UNKNOWN_SESSION_ID);
//   	   return 1;
      }

      // Now our state is setup with a cached master secret, so
      // we can derive keys, etc as normal

      // first we need to save our new client random from the hello message
      memcpy(&state->cipher_state->client_random, &cli_hello.random,
             sizeof(SSL_Random));

	   // Initialize the cipher suite
   	// Note: No error return from TLS_cipher_init
		_ssl_cipher_init(state, state->cipher_state->suite->suite_number);

      // Derive keys from state
      if(state->is_ssl_v3) {
         // Derive keys using SSLv3 algorithms
         ret_val = _ssl_v3_derive_keys(state);
      }
      else {
      	// Derive keys using TLSv1 algorithms
      	ret_val = _tls_1_derive_keys(state);
      }

      if(!ret_val) {
	      // Now that we have keys, we can initialize our bulk cipher
		   _ssl_bulk_cipher_init(state);
      }

		if(!ret_val) {
      	// Send the server hello
      	ret_val = _ssl_send_server_hello(state);
      }

	   if(!ret_val) {
		   // Send ChangeCipherSpec message
			ret_val = _ssl_send_chg_cipher_spec(state);
	   }

	   if(!ret_val) {
      	// Need to change to encrypted handshake to send
   	   // the finish message
			state->cur_state = SSL_STATE_ENC_SESS_RES;

		   // Send encrypted handshake finished message
			ret_val = _ssl_send_server_finish(state);

      	// Switch back to normal resume, since we are expecting
         // more unencrypted messages from the client.
         // This is sort of a hack, since we are actually
         // in the encrypted session resume handshake now, but
         // we need to read one more unencrypted message (Change Cipher Spec)
         // from the client. The state machine should probably have another
         // state added, like SESSION_RESUME_BEFORE_ENC, so we dont accidentally
         // _send_ unencrypted messages after this...
         state->cur_state = SSL_STATE_SESSION_RESUME;
	   }
#endif // Session renegotiation
   }
   else {
_ssl_hs_new_session:
   	// We have a new session, so initialize the state
	   // Initialize the cipher suite from the client hello message
	   if(_ssl_server_cipher_init(state, &cli_hello)) {
	      _ssl_send_fatal_alert(state, TLS_ALRT_handshake_failure);
      	state->cur_state = SSL_STATE_ERROR;
   	   return 1;
      }

		// Send back server hello
   	ret_val = _ssl_send_server_hello(state);   // Server hello
		if(!ret_val) {
	   	ret_val = _ssl_send_certificate(state); // Certificate
		}
   	if(!ret_val) {
	   	ret_val = _ssl_send_server_hello_done(state); 		// Hello done
	   }
	} // End session resume section

	return ret_val;
}

///////////////////////////////////////////////////////
// Process a server key exchange

/*** BeginHeader _ssl_do_server_key_exch */
int _ssl_do_server_key_exch(ssl_Socket*, SSL_Handshake_Hdr_t*, long);
/*** EndHeader */

__SSL_DEBUG__
int _ssl_do_server_key_exch(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                       		 long body)
{
	// NOT currently supported (Client TLS only)
	return 1; // Return failure for now (should not be called)
}

///////////////////////////////////////////////////////
// Process a client certificate request

/*** BeginHeader _ssl_do_cert_req */
int _ssl_do_cert_req(ssl_Socket*, SSL_Handshake_Hdr_t*, long);
/*** EndHeader */

__SSL_DEBUG__
int _ssl_do_cert_req(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                       		 long body)
{
	// 1) Send certificate
   // DEVIDEA: Check spec to make sure this is right
   return _ssl_send_certificate(state);       // Send Certificate
}

///////////////////////////////////////////////////////
// Process a client key exchange

/*** BeginHeader _ssl_do_client_key_exch */
int _ssl_do_client_key_exch(ssl_Socket*, SSL_Handshake_Hdr_t*, long);
/*** EndHeader */

__SSL_DEBUG__
int _ssl_do_client_key_exch(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                       		 long body)
{
   // 1) Process client ChangeCipherSpec message
   // 2) Derive symmetric key data
   // 3) Send ChangeCipherSpec message
   // 4) Send server handshake done message
	auto SSL_ClientKeyExchange cli_key_exch;
   auto unsigned int msg_len;
   auto long output, input; 	// Temporaries used by RSA decryption
   auto int ret_val;
   auto int alloc_size;

   ret_val = 0; // assume success
   alloc_size = 0;

#if _SSL_PRINTF_DEBUG
	printf("--->Received Client key exchange, Begin key derivation<---\n");
	printf("Encrypted PreMasterSecret length: %d\n", header->length[2]);
#endif
   // At this point, our raw message contains a handshake header
   // and a block of encrypted data, the PreMasterSecret

   // Do the RSA decryption to get the PreMasterSecret
   if(TLS_KX_RSA_512 == state->cipher_state->suite->key_exchange_alg) {
      // Get a couple buffers for public key decryption
      // MP_SIZE is the size of the multi-precision number buffers
      // used by the large number arithmetic library (which is used
      // to perform RSA operations)
      output = _ssl_alloc(state, MP_SIZE);
      alloc_size += MP_SIZE;
      input = _ssl_alloc(state, MP_SIZE);
      alloc_size += MP_SIZE;
      // Make sure we allocated ok
      if(!output || !input) {
         // TLS_errno is set by _ssl_alloc
         _ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
         state->cur_state = SSL_STATE_ERROR;
         _ssl_free(state, alloc_size);
         return 1;
      }
      xmemset(input, 0, MP_SIZE);
      xmemset(output, 0, MP_SIZE);

      // Get the encrypted message
      if(state->is_ssl_v3) {
	      xmem2xmem(input, body, RSA_KEY_LENGTH);
   	}
      else {
	      xmem2xmem(input, body + 2, RSA_KEY_LENGTH);
      }

#if _SSL_PRINTF_DEBUG
		printf("\n--->Encrypted Pre-Master Secret<---\n");
      print_xbytes(input, MP_SIZE);
      printf("\nDoing RSA Decrypt...\n");
#endif
		msg_len = _ssl_rsa_decrypt(state, input, output);
   }
   // Other supported key-exchange algorithms here
   else {
#if _SSL_PRINTF_DEBUG
			printf("***Key exchange algorithm choice invalid***\n");
#endif
    	// Error, we only support RSA 512
      _ssl_send_fatal_alert(state, TLS_ALRT_handshake_failure);
      state->cur_state = SSL_STATE_ERROR;
	   _ssl_free(state, alloc_size);
		return 1; // Error propagation
   }

#if _SSL_PRINTF_DEBUG
			printf("\n--->Decrypted Pre-Master Secret<---\n");
         print_xbytes(output, MP_SIZE);
#endif


  	// Check decrytped message length
   if(msg_len != sizeof(SSL_PreMasterSecret)) {
#if _SSL_PRINTF_DEBUG
			printf("***Key exchange decryption failure***\n");
#endif
     	// Error, unexpected message, handshake failure
      if(msg_len > 0) {
      	SSL_error(state, SSL_PUB_KEY_DECRYPTION_FAIL);
      }
      else {
			SSL_error(state, SSL_PUB_KEY_INT_ERROR);
      }
      state->cur_state = SSL_STATE_ERROR;
      _ssl_free(state, alloc_size);
      return 1;
   }

   // Copy message to our PreMasterSecret
   xmem2root(&cli_key_exch.exchange_keys, output, sizeof(SSL_PreMasterSecret));

   // We can now free the buffers
	if(alloc_size > 0) {
	   _ssl_free(state, alloc_size);
   }

   // Derive keys from message
   if(_ssl_cli_key_exch(state, &cli_key_exch)) {
    	// Error in key derivation
      _ssl_send_fatal_alert(state, TLS_ALRT_handshake_failure);
      state->cur_state = SSL_STATE_ERROR;
		return 1; // Error propagation
   }

   // Now we can initialize our bulk cipher
   // (there is no return from this function)
   _ssl_bulk_cipher_init(state);

#if _SSL_PRINTF_DEBUG
			printf("--->Bulk Cipher initialized<---\n");
#endif

	return ret_val;

}

///////////////////////////////////////////////////////
// Process a handshake finished message

/*** BeginHeader _ssl_do_hs_finish */
int _ssl_do_hs_finish(ssl_Socket*, SSL_Handshake_Hdr_t*, long);
/*** EndHeader */

__SSL_DEBUG__
int _ssl_do_hs_finish(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                       long body)
{
	// 1) Verify finished data
   // 2) Send change cipher spec (must change state->cur_state to
   //    SSL_STATE_HANDSHAKE, so that cipher spec message is not
   //    encrypted, change back to SSL_STATE_ENC_HANDSHAKE when done)
   // 3) Send encrypted handshake message

   auto int ret_val;

   ret_val = 0; // Assume success

#if _SSL_PRINTF_DEBUG
	printf("--->Received Handshake Finish Message<---\n");
#endif

	// Verify the finished hash
	if(_ssl_verify_finished(state, body)) {
#if _SSL_PRINTF_DEBUG
		printf("***Finish Verification Error***\n");
#endif
		SSL_error(state, SSL_FINISH_VERIFY_FAIL);
		return 1; // Error propagation
   }

#if _SSL_PRINTF_DEBUG
			printf("--->Finish Verification Success!!!<---\n");
#endif

	// Error handling allows each call to execute in succession
   // until something fails
   // Now we can digest the finished message, since we have verified
  	ret_val = _ssl_digest_hs_message(state, header, body);

   if(state->cur_state != SSL_STATE_ENC_SESS_RES) {
   	// Only send finish messages if in normal handshake
 	  	if(!ret_val) {
		   // Send ChangeCipherSpec message
			ret_val = _ssl_send_chg_cipher_spec(state);
  	 	}

	   if(!ret_val) {
		   // Send handshake finished message
			ret_val = _ssl_send_server_finish(state);
	   }
   }

   if(!ret_val) {
		// Ready to send and reeceive application data
		state->cur_state = SSL_STATE_APP_DATA;
   }

   return ret_val;
}

///////////////////////////////////////////////////////
// Process a server request message

/*** BeginHeader _ssl_do_server_request */
int _ssl_do_server_request(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                           long body);
/*** EndHeader */

__SSL_DEBUG__
int _ssl_do_server_request(ssl_Socket* state, SSL_Handshake_Hdr_t* header,
                           long body)
{
   auto int ret_val;

   ret_val = 0; // Assume success

	// Error handling allows each call to execute in succession
   // until something fails
  	ret_val = _ssl_digest_hs_message(state, header, body);

  	if(!ret_val) {
	   // Send reply message
		ret_val = _ssl_send_server_reply(state);
 	}

	// Close connection
	//state->cur_state = SSL_STATE_DONE;

   return ret_val;
}

/*** BeginHeader _ssl_choose_suite */
SSL_uint16_t _ssl_choose_suite(long, SSL_uint16_t);
/*** EndHeader */

// Selection uses pre-defined constant priorities for each suite.
// Priorities are in increasing order, with 0 being the lowest
// priority (which is also the error condition).
// The suites parameter is the physical address of an xmem buffer.
// The length parameter is the number of bytes in suites.
__SSL_DEBUG__
SSL_uint16_t _ssl_choose_suite(long suites, SSL_uint16_t length) {
   auto int i;
   auto int priority;	// Priority level of the current suite
   auto SSL_uint16_t cur_suite, temp; // Currently selected suite

#if _SSL_PRINTF_DEBUG
	printf("Client supported suites:\n");

	// Process the ciphersuite choices
   for(i = 0; i < length - (sizeof temp - 1u); ++i) {
   	temp = ntohs(xgetint(suites + (long) i));
		// Only print if a known suite
		if(strcmp(_ssl_get_suite_str(temp), "Unknown ciphersuite")) {
			printf("%s\n", _ssl_get_suite_str(temp));
      }
   }
#endif

   priority = 0;
   cur_suite = TLS_NULL_WITH_NULL_NULL; // If we return this, error
   for(i = 0; i < length - (sizeof temp - 1u); ++i) {
   	// the suite number is still in network short form, so convert
      temp = ntohs(xgetint(suites + i));

   	// See what we have
		switch(temp) {
		case TLS_NULL_WITH_NULL_NULL:
      			  if(TLS_NULL_NULL_NULL_PRI > priority) {
                  	priority =  TLS_NULL_NULL_NULL_PRI;
                     cur_suite = TLS_NULL_WITH_NULL_NULL;
                 }
                 break;
		case TLS_RSA_WITH_RC4_128_MD5:
      			  if(TLS_RSA_RC4_128_MD5_PRI > priority) {
                  	priority =  TLS_RSA_RC4_128_MD5_PRI;
                     cur_suite = TLS_RSA_WITH_RC4_128_MD5;
                 }
                 break;
		case TLS_RSA_WITH_RC4_128_SHA:
      			  if(TLS_RSA_RC4_128_SHA_PRI > priority) {
                  	priority =  TLS_RSA_RC4_128_SHA_PRI;
                     cur_suite = TLS_RSA_WITH_RC4_128_SHA;
                 }
                 break;
      // Currently unsupported suites
		case TLS_RSA_WITH_DES_CBC_SHA:
		case TLS_RSA_WITH_3DES_EBE_CBC_SHA:
		case TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA:
		case TLS_DH_anon_WITH_3DES_EDE_CBC_SHA:
		case TLS_RSA_WITH_AES_128_CBC_SHA:
		case TLS_DH_anon_WITH_AES_128_CBC_SHA:
      default:
					break;  // Do nothing
      }
   }

   // Finally, return the suite we selected
   return cur_suite;
}

/*** BeginHeader _ssl_session_save, _ssl_session_resume */
#if !SSL_NO_SESSION_RENEGOTIATION
int _ssl_session_save(ssl_Socket*);
int _ssl_session_resume(ssl_Socket*, long, SSL_uint16_t);
#endif
/*** EndHeader */

#if !SSL_NO_SESSION_RENEGOTIATION

// Our session cache
static int SSL_SESSION_RESUME_INDEX;
SSL_Session_Resume_t SSL_session_cache[SSL_MAX_SESS_RESUMES];

// Save a TLS session for later renegotiation
// Return 0 on success
__SSL_DEBUG__
int _ssl_session_save(ssl_Socket* state) {
	auto int index;
	auto SSL_CipherState* cipher;
   #GLOBAL_INIT {
   	// Clear our table
		memset(&SSL_session_cache, 0, sizeof(SSL_session_cache));
      SSL_SESSION_RESUME_INDEX = 0; // Reset the index into the table
   } // End #GLOBAL_INIT section

   cipher = state->cipher_state;

   // LOCK(SSL_SESSION_RESUME_INDEX)
   //	Get access index into session resume cache
	// First, check for existing session ID, so we can update it, rather
   // than adding a second copy
   for(index = 0; index < SSL_MAX_SESS_RESUMES; index++) {
    	if(!memcmp(cipher->session_id, SSL_session_cache[index].session_id,
                 cipher->session_id_length))
      {
       	break;
      }
   }

   // See if we got a match
   if(SSL_MAX_SESS_RESUMES == index) {
    	// we got a new session ID
	   index = SSL_SESSION_RESUME_INDEX;
   	SSL_SESSION_RESUME_INDEX++;
	   if(SSL_SESSION_RESUME_INDEX >= SSL_MAX_SESS_RESUMES) {
   		// Round-robin removal of old session resume items
	      SSL_SESSION_RESUME_INDEX = 0;
   	}
   }
#if _SSL_PRINTF_DEBUG
	else {
		printf("\n***Updating existing Session ID***\n");
   }
#endif

   // UNLOCK(SSL_SESSION_RESUME_INDEX)

#if _SSL_PRINTF_DEBUG
	printf("Session ID being saved for later resume:\n");
   print_bytes(cipher->session_id, cipher->session_id_length);
#endif

   // Save the pertinent data into the cache
   SSL_session_cache[index].suite_number = cipher->suite->suite_number;
   memcpy(&SSL_session_cache[index].master_secret, state->master_secret,
          sizeof(SSL_Secret));
   SSL_session_cache[index].session_id_length = cipher->session_id_length;
   memcpy(&SSL_session_cache[index].session_id, &cipher->session_id,
          cipher->session_id_length);

   return 0;
} // end TLS_session_save

// Resume a TLS session based upon a specific session ID receieved
// from the client
__SSL_DEBUG__
int _ssl_session_resume(ssl_Socket* state, long sess_id_xmem,
                       SSL_uint16_t sess_id_len)
{
	auto int index;
	auto SSL_CipherState* cipher;
   auto SSL_byte_t sess_id[SSL_MAX_SESSION_ID];

   if(sess_id_len > SSL_TEMP_BUF_SIZE) {
    	// Error, internal buffer too small
      return 1;
   }
   xmem2root(sess_id, sess_id_xmem, sess_id_len);

   // We want to lock the cache through this entire function, so it
   // cannot be modified before we get a chance to copy over our data
   // This should not be too much of a problem, unless a lot of connections
   // want to resume all at once, then they will have to wait!
   // LOCK(SSL_session_cache)
   // Search the SSL_session_cache for a matching session ID
   for(index = 0; index < SSL_MAX_SESS_RESUMES; index++) {
    	if(!memcmp(sess_id, SSL_session_cache[index].session_id, sess_id_len)) {
       	break;
      }
   }

   // Make sure we got a match
   if(index == SSL_MAX_SESS_RESUMES) {
    	// Error, we got an invalid session ID
      return 1;
   }

   cipher = state->cipher_state;

   // Index now points into the cache, copy our data over to our state
   cipher->suite->suite_number = SSL_session_cache[index].suite_number;
   memcpy(state->master_secret, &SSL_session_cache[index].master_secret,
          sizeof(SSL_Secret));
   cipher->session_id_length = SSL_session_cache[index].session_id_length;
   memcpy(&cipher->session_id, &SSL_session_cache[index].session_id,
          cipher->session_id_length);
   // UNLOCK(SSL_session_cache)

	return 0;
}
#else
// Trying to use this function without first enabling session renegotiation
#error "INTERNAL LIBRARY ERROR: referencing _ssl_session_save or " \
       "_ssl_session_resume with SSL_NO_SESSION_RENEGOTIATION set to 1"
#endif

/*** BeginHeader _ssl_get_session_ID_seed */
void _ssl_get_session_ID_seed(SSL_byte_t seed[HMAC_MD5_HASH_SIZE],
                              SSL_byte_t *in_seed);
/*** EndHeader */

// Build the Session ID seed, used for indexing the Session renegotiation
// cache
__SSL_DEBUG__
void _ssl_get_session_ID_seed(SSL_byte_t seed[HMAC_MD5_HASH_SIZE],
                              SSL_byte_t in_seed[SESS_ID_SEED_SIZE])
{
	// Seed is an MD5 hash
   auto md5_state_t md5;
   auto SSL_byte_t buf[SESS_ID_SEED_SIZE];
   auto int i;

   // Copy the seed into the buffer
   memcpy(buf, SESSION_ID_SEED_1, SESS_ID_SEED_SIZE);

   // First, XOR the input seed and the base seed
   for(i = 0; i < SESS_ID_SEED_SIZE; i++)
   {
    	buf[i] = buf[i] ^ in_seed[i];
   }

   // Build the final seed
   md5_init(&md5);
   md5_append(&md5, buf, SESS_ID_SEED_SIZE);
	md5_finish(&md5, seed);
}

/*** BeginHeader _ssl_server_cipher_init */
int _ssl_server_cipher_init(ssl_Socket*, SSL_ClientHello*);
/*** EndHeader */

// Initialize the ciphersuire state from a client_hello message
// This should only be called during the INITIAL handshake, NOT
// during a RESUME
// Return 0 on success, Non-zero on failure (set TLS_errno)
__SSL_DEBUG__
int _ssl_server_cipher_init(ssl_Socket* state, SSL_ClientHello* cli_hello_ptr)
{
	auto SSL_CipherState* cipher;
   auto SSL_SuiteConfig* suite;
   auto SSL_uint16_t suite_number;
   auto SSL_byte_t rand_buf[SSL_MAX_SESSION_ID - HMAC_MD5_HASH_SIZE];
   auto SSL_byte_t seed_buf[HMAC_MD5_HASH_SIZE];
	auto int i, ret_val;

   ret_val = 0;

	// Access to state members
   cipher = state->cipher_state;
   suite = cipher->suite;

   // Set up the cipher suite, based on the suite selection
   // from the client offer (ciphersuite_length is the number of BYTES
   // in the ciphersuite array)
	suite_number = _ssl_choose_suite(cli_hello_ptr->cipher_suites,
                                    cli_hello_ptr->ciphersuite_length);

   // Check the suite choice
	if(TLS_NULL_WITH_NULL_NULL == suite_number) {
    	// Oops, did not find a compatible ciphersuite
      SSL_error(state, SSL_CIPHER_CHOICE_ERROR);
      return 1; // Return immediately
   }

   // Initialize the cipher, basec upon our selection
   // Note: No error return from TLS_cipher_init
	_ssl_cipher_init(state, suite_number);

  	// Create a new session ID
   // DEVIDEA: In the future, we need to check for the existence of
   // this session ID accross all instances of TLS connections,
   // due to the random element

	// Get the random part of the Session ID
   cipher->session_id_length = SSL_MAX_SESSION_ID;
   _ssl_big_rand(rand_buf, sizeof(rand_buf));

   // Get the seed for the Session ID
	_ssl_get_session_ID_seed(seed_buf, SESSION_ID_SEED_2);

   for(i = 0; i < SSL_MAX_SESSION_ID; i++) {
   	// Build the session ID from the seed and the random data
	   cipher->session_id[i] = (i & 0x1 == 1)?
                               seed_buf[i >> 1] : rand_buf[i >> 1];
   }

#if _SSL_PRINTF_DEBUG
	printf("Session ID:\n");
   print_bytes(cipher->session_id, cipher->session_id_length);
#endif

   // Copy the client random into our state
  	memcpy(&cipher->client_random, &cli_hello_ptr->random, sizeof(SSL_Random));

   // Success
   return 0;
}

/*** BeginHeader _ssl_cipher_init */
void _ssl_cipher_init(ssl_Socket*, SSL_uint16_t);
/*** EndHeader */

// Set up cipher suite, based upon selected suite (which is selected
// by caller and stored in state->cipher_state)
// DEVIDEA: Use constant structs for initialization?
__SSL_DEBUG__
void _ssl_cipher_init(ssl_Socket* state, SSL_uint16_t suite_number) {
	auto SSL_CipherState* cipher;
   auto SSL_SuiteConfig* suite;
   auto SSL_uint32_t time_stamp;

   cipher = state->cipher_state;
   suite = cipher->suite;

   // Set up our number and text name
	suite->suite_number = suite_number;
	suite->fulltext_name = _ssl_get_suite_str(suite_number);

   // Clear sequence number
  	memset(cipher->seq_number, 0, SSL_SEQ_NUM_SIZE);
  	memset(cipher->rd_seq_number, 0, SSL_SEQ_NUM_SIZE);

   // Setup the server random for generating key material
	// The time stamp needs to be a UNIX time stamp, so
   // calculate the value from the SEC_TIMER
   time_stamp = SEC_TIMER + RTC_EPOCH_DIFF;

   cipher->server_random.gmt_unix_time = htonl(time_stamp);
  	_ssl_big_rand(cipher->server_random.random_bytes, SSL_RANDOM_SIZE);


#if _SSL_PRINTF_DEBUG
    printf("\nUsing ciphersuite: %s\n", suite->fulltext_name);
#endif

///////////////////////////////////////////////////////
   // Set up ciphersuite
   if(TLS_RSA_WITH_RC4_128_MD5 == suite_number||
		TLS_RSA_WITH_RC4_128_SHA == suite_number)
   {
	  	suite->key_exchange_alg = TLS_KX_RSA_512;
// DEVIDEA: Certificate authentication is not yet supported
//		suite->authentication_alg = TLS_AUTH_RSA;
		suite->bulk_cipher_alg = TLS_CIPHER_RC4_128;
   }

   if(TLS_RSA_WITH_RC4_128_MD5 == suite_number) {
   		suite->digest_alg = TLS_DIGEST_MD5;
	}

   if(TLS_RSA_WITH_RC4_128_SHA == suite_number) {
   		suite->digest_alg = TLS_DIGEST_SHA;
	}

///////////////////////////////////////////////////////
   // Set up key exchange algorithms
   if(TLS_KX_RSA_512 == suite->key_exchange_alg) {
		cipher->key_exch->key_size = 512;
		cipher->key_exch->encrypt = RSA_op;
		cipher->key_exch->decrypt = RSA_op;
   }

///////////////////////////////////////////////////////
// DEVIDEA: Certificate authentication is not yet supported
   // Set up authentication
/*
	if(TLS_AUTH_RSA == suite->authentication_alg) {
      cipher->auth;
		SSL_uint16_t key_size;
		SSL_uint16_t (*sign)();
		SSL_uint16_t (*verify)();
   }
*/
///////////////////////////////////////////////////////
   // Set up bulk cipher
	if(TLS_CIPHER_RC4_128 == suite->bulk_cipher_alg) {
		cipher->bulk_cipher->key_size = 16; // Bytes = 128/8
		cipher->bulk_cipher->block_size = 0;
		cipher->bulk_cipher->init = RC4_init;
		cipher->bulk_cipher->encrypt = RC4_xop;
		cipher->bulk_cipher->decrypt = RC4_xop;
   }

 	// Add cipher block size to write reserve footer, so we have space
   // for cipher block padding, if needed
   state->write_state->footer_reserve += cipher->bulk_cipher->block_size;

///////////////////////////////////////////////////////

	if(state->is_ssl_v3) {
   	// Use SSLv3 digest methods
      // We use the HMAC constants for this, because the SSLv3 MAC is derived
      // from an early version of HMAC, so we can reuse the values
	   cipher->digest->init = _ssl_v3_mac_hash_init;
	   cipher->digest->add = _ssl_v3_mac_hash_append;
	   cipher->digest->finish = _ssl_v3_mac_hash_finish;

	   if(TLS_DIGEST_MD5 == suite->digest_alg) {
	      // Use SSLv3 MAC hash for digests
	      _ssl_v3_mac_init(&cipher->digest->state, HMAC_USE_MD5);
	      cipher->digest->hash_size = HMAC_MD5_HASH_SIZE;

		   // Set these here for use later
	      cipher->server_mac_sec_size = HMAC_MD5_HASH_SIZE;
	      cipher->client_mac_sec_size = HMAC_MD5_HASH_SIZE;
	   }

	   if(TLS_DIGEST_SHA == suite->digest_alg) {
	      // Use SSLv3 MAC hash for digests
	      _ssl_v3_mac_init(&cipher->digest->state, HMAC_USE_SHA);
	      cipher->digest->hash_size = HMAC_SHA_HASH_SIZE;
		   // Set these here for use later
	      cipher->server_mac_sec_size = HMAC_SHA_HASH_SIZE;
	      cipher->client_mac_sec_size = HMAC_SHA_HASH_SIZE;
	   }
   }
   else {
	   // Set up digest algorithm (TLS only uses HMAC)
	   cipher->digest->init = HMAC_hash_init;
	   cipher->digest->add = HMAC_hash_append;
	   cipher->digest->finish = HMAC_hash_finish;

	   if(TLS_DIGEST_MD5 == suite->digest_alg) {
	      // TLS uses HMAC for digests
	      HMAC_init(&cipher->digest->state, HMAC_USE_MD5);
	      cipher->digest->hash_size = HMAC_MD5_HASH_SIZE;

			// Set these here for use later
         cipher->server_mac_sec_size = HMAC_MD5_HASH_SIZE;
	      cipher->client_mac_sec_size = HMAC_MD5_HASH_SIZE;
	   }

	   if(TLS_DIGEST_SHA == suite->digest_alg) {
	      // TLS uses HMAC for digests
	      HMAC_init(&cipher->digest->state, HMAC_USE_SHA);
	      cipher->digest->hash_size = HMAC_SHA_HASH_SIZE;

		   // Set these here for use later
	      cipher->server_mac_sec_size = HMAC_SHA_HASH_SIZE;
	      cipher->client_mac_sec_size = HMAC_SHA_HASH_SIZE;
	   }
   }

///////////////////////////////////////////////////////
}

/*** BeginHeader _ssl_bulk_cipher_init */
void _ssl_bulk_cipher_init(ssl_Socket*);
/*** EndHeader */

// Initialize the bulk cipher algorithms
__SSL_DEBUG__
void _ssl_bulk_cipher_init(ssl_Socket* state) {
   auto SSL_BulkCipherConfig* bulk_cipher;

   bulk_cipher = state->cipher_state->bulk_cipher;

   // We can now initialize our bulk cipher
   if(state->ssl_mode == SSL_MODE_SERVER_BINARY ||
   	state->ssl_mode == SSL_MODE_SERVER_ASCII ) {
      // Init read cipher
		bulk_cipher->init(&bulk_cipher->read_state, bulk_cipher->direction,
   	                  bulk_cipher->client_key, bulk_cipher->key_size,
      	               bulk_cipher->client_iv);

	   // Init write cipher
		bulk_cipher->init(&bulk_cipher->write_state, bulk_cipher->direction,
      	               bulk_cipher->server_key, bulk_cipher->key_size,
         	            bulk_cipher->server_iv);
   }
   else {
    	// Client SSL, read/write keys are swapped
   }
}

/*** BeginHeader _ssl_send_server_hello */
int _ssl_send_server_hello(ssl_Socket*);
/*** EndHeader */

// Send a server_hello based upon the current TLS state
// return 0 on success, non-zero on failure (set TLS_errno)
__SSL_DEBUG__
int _ssl_send_server_hello(ssl_Socket* state) {
   auto SSL_Handshake_Hdr_t header;
   auto SSL_ProtocolVersion version;
   auto SSL_uint16_t suite_num;
	auto SSL_CipherState* cipher;	 // Pointers to state internals
   auto SSL_SuiteConfig* suite;
   auto SSL_uint16_t length;      // Message length, also used as an offset
   auto long xbuf;
   auto int ret_val;
   auto int alloc_size;

   ret_val = 0;
   alloc_size = 0;
   cipher = state->cipher_state;
   suite = cipher->suite;

   // Allocate buffer
   xbuf = _ssl_alloc(state, SSL_MAX_HANDSHAKE_SIZE);
   alloc_size += SSL_MAX_HANDSHAKE_SIZE;
	if(!xbuf) {
   	// Allocation error
		_ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }

   // Build the ServerHello message

   // Skip the header, we will fill it in at the end
   length = sizeof(SSL_Handshake_Hdr_t);

	// Server version
   if(state->is_ssl_v3) {
		version.major = SSL3_VER_MAJ;
	   version.minor = SSL3_VER_MIN;
   }
   else {
		version.major = TLS1_VER_MAJ;
	   version.minor = TLS1_VER_MIN;
	}

   root2xmem(xbuf + length, &version, sizeof(SSL_ProtocolVersion));
   length += sizeof(SSL_ProtocolVersion);

   // Server random
   root2xmem(xbuf + length, &cipher->server_random, sizeof(SSL_Random));
   length += sizeof(SSL_Random);

   // Session ID
	root2xmem(xbuf + length, &cipher->session_id_length, sizeof(SSL_byte_t));
   length += sizeof(SSL_byte_t);
   if(cipher->session_id_length > 0) {
	   root2xmem(xbuf + length, &cipher->session_id, cipher->session_id_length);
	   length += cipher->session_id_length;
   }

   // The suite number must be switched to a network short to be processed
   // correctly (using htons)
   suite_num = htons(suite->suite_number);
   root2xmem(xbuf + length, &suite_num, sizeof(SSL_uint16_t));
   length += sizeof(SSL_uint16_t);

   // There are no compression methods, so just send length of 0
   xsetint(xbuf + length, 0x0000);
	length++;

	// Set the message length (not including header) and message type
   ulton24(header.length, length - sizeof(SSL_Handshake_Hdr_t));
	header.msg_type = server_hello;

   // Copy the header into the beginning
   root2xmem(xbuf, &header, sizeof(SSL_Handshake_Hdr_t));

   // Digest the handshake message for the Finish MAC
	ret_val = _ssl_digest_hs_message(state, &header, xbuf +
                                    sizeof(SSL_Handshake_Hdr_t));

   // Write the new record
   if(!ret_val) {
		if(ssl_xfastwrite(state, xbuf, length) != length) {
       	ret_val = 1;
      }
      else if(ssl_create_record(state)) {
       	ret_val = 1;
#if _SSL_PRINTF_DEBUG
	   	printf("Error in creating new record\n");
#endif
	   }
   }

   // Free buffer
   _ssl_free(state, alloc_size);

   return ret_val;
}

/*** BeginHeader _ssl_send_certificate */
int _ssl_send_certificate(ssl_Socket*);
/*** EndHeader */

// Send the certificate via a handshake message
// return 0 on success, non-zero on failure (set TLS_errno)
__SSL_DEBUG__
int _ssl_send_certificate(ssl_Socket* state) {
   auto SSL_Handshake_Hdr_t header;
   auto SSL_byte_t tmp_len[3];
   auto SSL_uint16_t length; // Length of the message, also used as an offset
   auto long xbuf;
   auto int ret_val;
   auto int alloc_size;

   ret_val = 0;
   alloc_size = 0;

	if(state->cert->cert_size >= SSL_MAX_RECORD_DATA_LENGTH) {
   	SSL_error(state, SSL_CERT_TOO_BIG);
      return 1;
   }

   // Allocate buffer
   xbuf = _ssl_alloc(state, SSL_MAX_RECORD_DATA_LENGTH);
   alloc_size += SSL_MAX_RECORD_DATA_LENGTH;
	if(!xbuf) {
   	// Allocation error
		_ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }

   // Sending a certificate handshake message

   // Skip the header, we will fill it in at the end
   length = sizeof(SSL_Handshake_Hdr_t);

   // Build the message

   // Total certificates length (length of all certificates)
   // Note the 3 added to the cert length, this compensates for
   // the individual certificate length field, added next
   // (we only support 1 certificate for now)
   ulton24(tmp_len, state->cert->cert_size + 3);
	root2xmem(xbuf + length, tmp_len, 3);
   length += 3;

  	// Individual certificate length field
   ulton24(tmp_len, state->cert->cert_size);
	root2xmem(xbuf + length, tmp_len, 3);
   length += 3;

   // Send the cert
	// DEVIDEA: Need Error Checking?
	SSL_extract_cert(state->cert, xbuf + length);
   length += state->cert->cert_size;

   // Length actually starts AFTER header, but since we are also using it as
   // an offset, we need to adjust here
   ulton24(header.length, length - sizeof(SSL_Handshake_Hdr_t));
	header.msg_type = certificate;

   // Copy the header into the beginning
   root2xmem(xbuf, &header, sizeof(SSL_Handshake_Hdr_t));

   // Add this message to the digest, use raw buffer for the digest
   ret_val = _ssl_digest_hs_message(state, &header, xbuf +
                                    sizeof(SSL_Handshake_Hdr_t));

   // Write the new record
   if(!ret_val) {
		if(ssl_xfastwrite(state, xbuf, length) != length) {
       	ret_val = 1;
      }
      else if(ssl_create_record(state)) {
       	ret_val = 1;
#if _SSL_PRINTF_DEBUG
	   	printf("Error in creating new record\n");
#endif
	   }
   }

   // Free the buffer
	_ssl_free(state, alloc_size);

   return ret_val;
}

/*** BeginHeader _ssl_send_server_hello_done */
int _ssl_send_server_hello_done(ssl_Socket*);
/*** EndHeader */

// Send a server_hello based upon the current TLS state
// return 0 on success, non-zero on failure (set TLS_errno)
__SSL_DEBUG__
int _ssl_send_server_hello_done(ssl_Socket* state) {
   auto SSL_Handshake_Hdr_t header;
   auto int ret_val;
   auto long xbuf;
	auto int alloc_size;

   ret_val = 0;
	alloc_size = 0;

   xbuf = _ssl_alloc(state, sizeof(SSL_Handshake_Hdr_t));
   alloc_size += sizeof(SSL_Handshake_Hdr_t);
	if(!xbuf) {
   	// Allocation error
		_ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }

   // Length of a ServerHelloDone is 0
   memset(&header, 0, sizeof(SSL_Handshake_Hdr_t));
   header.msg_type = server_hello_done;

   // Add this message to the digest, use raw buffer for the digest
  	ret_val = _ssl_digest_hs_message(state, &header, xbuf);

   root2xmem(xbuf, &header, sizeof(SSL_Handshake_Hdr_t));

   // Write the record
   if(!ret_val) {
	   if(ssl_xfastwrite(state, xbuf, sizeof(SSL_Handshake_Hdr_t)) !=
                        sizeof(SSL_Handshake_Hdr_t))
      {
    		ret_val = 1;
      }
      else if(ssl_create_record(state)) {
       	ret_val = 1;
#if _SSL_PRINTF_DEBUG
	   	printf("Error in creating new record\n");
#endif
	   }
   }

   // Free our buffer
   _ssl_free(state, alloc_size);

   return ret_val;
}

/*** BeginHeader _ssl_rsa_decrypt */
int _ssl_rsa_decrypt(ssl_Socket*, long, long);
/*** EndHeader */

// Do an RSA decryption using the initialized key exchange ciphersuite
// Input and output must be of size MP_SIZE and in xmem
// Returns number of bytes decrypted on success, -1 on error
__SSL_DEBUG__
int _ssl_rsa_decrypt(ssl_Socket* state, long xinput, long xoutput)
{
	auto SSL_byte_t pkey[MP_SIZE], modulus[MP_SIZE];
   auto SSL_byte_t temp[MP_SIZE], input[MP_SIZE], output[MP_SIZE];
   auto unsigned int msg_len;

   // Check key size
   if(state->cert->key_size != RSA_KEY_LENGTH) {
   	SSL_error(state, SSL_RSA_KEY_SIZE_ERROR);
		return -1;
   }

   // Clear our buffers
   memset(pkey, 0, MP_SIZE);
   memset(modulus, 0, MP_SIZE);

   // Convert data and keys

	// Extract keys from import certificate file
   // RSA_PKCS1 decryption expects MP format
   // so we use bin2mp (MPARITH.LIB) to convert
   SSL_extract_rsa_mod(state->cert, temp);
	bin2mp(temp, modulus, RSA_KEY_LENGTH);
	SSL_extract_rsa_pkey(state->cert, temp);
	bin2mp(temp, pkey, RSA_KEY_LENGTH);

   // RSA operations work only on root data, so copy
   // input to our root buffer
   xmem2root(input, xinput, MP_SIZE);

   // Do the decryption
	msg_len = RSA_PKCS1v1_5_Decrypt(modulus, pkey, input, output);

   // Copy root output to xmem return buffer
   root2xmem(xoutput, output, MP_SIZE);

   return msg_len;
}

/*** BeginHeader _ssl_send_chg_cipher_spec */
int _ssl_send_chg_cipher_spec(ssl_Socket*);
/*** EndHeader */

// Send a server_hello based upon the current SSL state
// Return 0 on success, non-zero on fail (set SSL_errno)
__SSL_DEBUG__
int _ssl_send_chg_cipher_spec(ssl_Socket* state)
{
	auto SSL_state_t save_state;
   auto int msg;

   // Save our current state, switch to change cipher spec state
   save_state = state->cur_state;
   if(SSL_STATE_SESSION_RESUME == state->cur_state) {
   	// If we are doing a session resume, then state is
      // session resume cipher spec
      state->cur_state = SSL_STATE_SESS_RES_CH_SPEC;
   }
   else {
   	// All other cases, do normal cipher spec
	   state->cur_state = SSL_STATE_CH_CIPHER_SPEC;
   }

   // The entire change_cipher_spec message consists of a single byte
   // of value 0x1
	msg = 0x1;

   // Write the message
   if(ssl_xfastwrite(state, paddrSS(&msg), 1) != 1)
   {
    	state->cur_state = SSL_STATE_ERROR;
 		return 1; // Failure in ssl_xwrite
   }
   // Create a new record
   else if(ssl_create_record(state)) {
#if _SSL_PRINTF_DEBUG
      printf("Error in creating new record\n");
#endif
      state->cur_state = SSL_STATE_ERROR;
      return 1; // Failure in ssl_xwrite
   }

   // Restore previous state
	state->cur_state = save_state;

   return 0;
}

/*** BeginHeader _ssl_send_server_reply */
int _ssl_send_server_reply(ssl_Socket* state);
/*** EndHeader */

// Send a server reply message in response to a server request message
// from the client
__SSL_DEBUG__
int _ssl_send_server_reply(ssl_Socket* state)
{
   auto SSL_uint16_t msg;
   auto int bytes_written;

   // Set the message
	msg = SSL_HS_SERVER_REPLY;

   // Set the server reply message state
   state->cur_state = SSL_STATE_SERVER_REPLY;

   // Send the message
   bytes_written = ssl_xfastwrite(state, paddrSS((SSL_byte_t*)&msg),
                                   sizeof(SSL_uint16_t));
   if(bytes_written != sizeof(SSL_uint16_t)) {
#if _SSL_PRINTF_DEBUG
      printf("Could not write message\n");
#endif
	   state->cur_state = SSL_STATE_ERROR;
      return 1;
   }
   else if(ssl_create_record(state)) {
		// Create a new record from the data we just wrote
#if _SSL_PRINTF_DEBUG
      printf("Error in creating new record\n");
#endif
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }

   // Set the state machine to done (the connection will be closed)
//	state->cur_state = SSL_STATE_DONE;

   return 0;
}

/*** BeginHeader _ssl_send_server_finish */
int _ssl_send_server_finish(ssl_Socket*);
/*** EndHeader */

// Send a finish message based upon the current TLS state
// Return 0 on success, non-zero on fail (set TLS_errno)
// Note that SSL3_VERIFY_DATA_SIZE is larger than TLS_VERIFY_DATA_SIZE
__SSL_DEBUG__
int _ssl_send_server_finish(ssl_Socket* state)
{
   auto SSL_Handshake_Hdr_t header;
   auto long xbuf;
   auto SSL_byte_t mac[SSL3_VERIFY_DATA_SIZE];
   auto SSL_uint32_t length;
   auto int ret_val;
   auto int alloc_size;

   ret_val = 0;
   alloc_size = 0;

   // Allocate buffers
   xbuf = _ssl_alloc(state, sizeof(SSL_Handshake_Hdr_t) +
                     SSL3_VERIFY_DATA_SIZE);
   alloc_size += sizeof(SSL_Handshake_Hdr_t) + SSL3_VERIFY_DATA_SIZE;
	if(!xbuf) {
   	// Allocation error
		_ssl_send_fatal_alert(state, TLS_ALRT_internal_error);
      state->cur_state = SSL_STATE_ERROR;
      return 1;
   }

   // Skip the header, we will fill it in later
   length = (SSL_uint32_t)sizeof(SSL_Handshake_Hdr_t);

	// Generate the mac
   if(state->is_ssl_v3) {
		_ssl_v3_generate_finish_mac(state, state->fin_hash_write,
   	                            SSL_FMAC_SERVER, mac);

	   // Copy in the verify data
	   root2xmem(xbuf + (unsigned int)length, mac, SSL3_VERIFY_DATA_SIZE);
  		length += (SSL_uint32_t)SSL3_VERIFY_DATA_SIZE;
   }
   else {
		_tls_1_generate_finish_mac(state, state->fin_hash_write,
   	                           SSL_FMAC_SERVER, mac);

	   // Copy in the verify data
	   root2xmem(xbuf + (unsigned int)length, mac, TLS_VERIFY_DATA_SIZE);
  		length += (SSL_uint32_t)TLS_VERIFY_DATA_SIZE;
   }

   // Fill in the header
   memset(&header, 0, sizeof(SSL_Handshake_Hdr_t));
	ulton24(header.length, length - sizeof(SSL_Handshake_Hdr_t));
   header.msg_type = finished;

   // Copy header into buffer
   root2xmem(xbuf, &header, sizeof(SSL_Handshake_Hdr_t));

   // Add this message to the digest, use raw buffer for the digest
   ret_val = _ssl_digest_hs_message(state, &header, xbuf +
                                    sizeof(SSL_Handshake_Hdr_t));

   // Write the new record
   if(!ret_val) {
		if(ssl_xfastwrite(state, xbuf, (SSL_uint16_t)length) != (int)length) {
       	ret_val = 1;
      }
	   else if(ssl_create_record(state)) {
       	ret_val = 1;
#if _SSL_PRINTF_DEBUG
	      printf("Error in creating new record\n");
#endif
	   }
   }

   // Free (in reverse order)
   _ssl_free(state, alloc_size);

   return ret_val;
}

/*** BeginHeader _ssl_cli_key_exch */
int _ssl_cli_key_exch(ssl_Socket*, SSL_ClientKeyExchange*);
/*** EndHeader */

// Derive symmetric keys from a client key exchange message
// Return 0 on success, non-zero on fail (set TLS_errno)
__SSL_DEBUG__
int _ssl_cli_key_exch(ssl_Socket* state, SSL_ClientKeyExchange* cli_key_exch) {
	auto SSL_Secret master_secret, pre_master_secret;
	auto SSL_CipherState* cipher;			// Pointers to state internals
   auto SSL_byte_t output[SSL_KEY_BLOCK_SIZE], out_temp[SSL_KEY_BLOCK_SIZE];
   auto SSL_byte_t seeded_label[SSL_SEEDED_LABEL_MAX];
   auto unsigned int label_len;
   auto int i;

   // Access to state internals
   cipher = state->cipher_state;

   // Check Protcol Version
   if(state->is_ssl_v3) {
	   if(!((cli_key_exch->exchange_keys.client_version.major == SSL3_VER_MAJ) &&
           (cli_key_exch->exchange_keys.client_version.minor == SSL3_VER_MIN)))
	   {
   		SSL_error(state, SSL_EXCH_KEYS_PROTOCOL_VER);
			return 1;
   	}
   }
   else {
   	if(!(cli_key_exch->exchange_keys.client_version.major == TLS1_VER_MAJ &&
           cli_key_exch->exchange_keys.client_version.minor == TLS1_VER_MIN))
   	{
   		SSL_error(state, SSL_EXCH_KEYS_PROTOCOL_VER);
			return 1;
   	}
   }

   // Fill our pre master secret data structure
	memcpy(&pre_master_secret.data, &cli_key_exch->exchange_keys,
          sizeof(SSL_PreMasterSecret));
   pre_master_secret.length = sizeof(SSL_PreMasterSecret);

#if _SSL_PRINTF_DEBUG
   printf("\nClient Random:\n");
   print_bytes((SSL_byte_t*)&cipher->client_random, sizeof(SSL_Random));
   printf("\nServer Random:\n");
   print_bytes((SSL_byte_t*)&cipher->server_random, sizeof(SSL_Random));
   printf("\nPre Master Secret:\n");
   print_bytes(pre_master_secret.data, pre_master_secret.length);
#endif

   // ***Derive the Master Secret***
   memset(out_temp, 0, SSL_KEY_BLOCK_SIZE);
   memset(output, 0, SSL_KEY_BLOCK_SIZE);
   if(state->is_ssl_v3) {
   	// Derive the Master Secret using SSLv3 hash expansion
		_ssl_v3_hash_expand(&pre_master_secret,
                          (SSL_byte_t*)&cipher->client_random,
                          (SSL_byte_t*)&cipher->server_random,
                          output, SSL_MASTER_SEC_SIZE);
   }
   else {
	   // Build the label to be used in the key derivation
	   // Seeded label = MASTER_SEC_LABEL + client random + server random
	   memcpy(seeded_label, TLS_MASTER_SEC_LABEL, strlen(TLS_MASTER_SEC_LABEL));
	   label_len = strlen(TLS_MASTER_SEC_LABEL);
	   memcpy(seeded_label + label_len, &cipher->client_random,
	          sizeof(SSL_Random));
	   label_len += sizeof(SSL_Random);
	   memcpy(seeded_label + label_len, &cipher->server_random,
	          sizeof(SSL_Random));
	   label_len += sizeof(SSL_Random);

      // Derive the Master Secret using the TLS PRF
		_tls_1_PRF(&pre_master_secret, seeded_label, label_len, output,
   	         out_temp, SSL_MASTER_SEC_SIZE);
   }

   // Save our secret for use in key block derivation
   memset(&master_secret, 0, sizeof(SSL_Secret));
   memcpy(&master_secret.data, output, SSL_MASTER_SEC_SIZE);
   master_secret.length = SSL_MASTER_SEC_SIZE;

#if _SSL_PRINTF_DEBUG
   printf("\nMaster Secret:\n");
   print_bytes(master_secret.data, master_secret.length);
#endif

	// Save off our master secret for use in the Finished calculation
   memcpy(state->master_secret, &master_secret, sizeof(SSL_Secret));

	// Derive our session keys from the master secret
   // DEVIDEA: Consolidate key derivation
   if(state->is_ssl_v3) {
	   if(!_ssl_v3_derive_keys(state)) {
	      return 0;
	   }
   }
   else {
	   if(!_tls_1_derive_keys(state)) {
	      return 0;
	   }
   }

   // Key derivation failure
   return 1;
}


/*** BeginHeader _ssl_verify_finished */
int _ssl_verify_finished(ssl_Socket*, long);
/*** EndHeader */

// Returns 0 on success, non-zero on failure
// body is a pointer to an xmem buffer
__SSL_DEBUG__
int _ssl_verify_finished(ssl_Socket* state, long body) {
	// SSL3_VERIFY_DATA_SIZE is greater than TLS_VERIFY_DATA_SIZE and is
   // therefore used as the dimension of these buffers
	auto SSL_byte_t mac[SSL3_VERIFY_DATA_SIZE], buf[SSL3_VERIFY_DATA_SIZE];
   auto SSL_byte_t ret_val;

   ret_val = 0;

	// Generate the mac
   if(state->is_ssl_v3) {
		ret_val = _ssl_v3_generate_finish_mac(state, state->fin_hash_read,
   	                                      SSL_FMAC_CLIENT, mac);
	   // Now for the compare
	   if(!ret_val) {
	      xmem2root(buf, body, SSL3_VERIFY_DATA_SIZE);
	      ret_val = memcmp(mac, buf, SSL3_VERIFY_DATA_SIZE);
	   }
   }
	else {
		ret_val = _tls_1_generate_finish_mac(state, state->fin_hash_read,
   				                            SSL_FMAC_CLIENT, mac);
	   // Now for the compare
	   if(!ret_val) {
	      xmem2root(buf, body, TLS_VERIFY_DATA_SIZE);
	      ret_val = memcmp(mac, buf, TLS_VERIFY_DATA_SIZE);
	   }
   }

	return ret_val;
}

/*** BeginHeader */
#endif
/*** EndHeader */